subsystem = NFIRAOS
component = rtc

description = NRTC Assembly commands.

receive = [
  {
    name            = init
    description     = """Request Command.

The initialize command restores NRTC software to the state immediately after a boot-up. This command the stops the NRTC pipeline, via the pipeline_stop command, and will reset all internal states to default values, clear any mode configuration parameters and then request the specified configuration file from the TMT Configuration Service. Upon receiving the configuration file from the TMT configuration service, the NRTC will parse the configuration data and load it into memory. After the configuration file has been read, the NRTC will (re-)establishes communication with the RPG. An equivalent result to this command can be achieved by restarting all NRTC software.

Discussion: There should be a convention to tell the NRTC to use a local version of the configure file(s) for engineering/integration purposes when the TMT configuration service is not yet available. This could be embedded in the configuration name/version.

Precondition:
<ul>
<li> none
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.mode = false
<li> config.name = {input}
<li> config.version = {input}
<li> all other internal parameters set to default values
</ul>"""
    args = [
      {
        name        = configName 
        description = Name of the configuration file to get from the TMT Configuration Service
        type        = string
      }
      {
        name        = configVersion
        description = Version of the configuration file to get from the TMT Configuration Service
        type        = string 
      }
    ]
  }  

  {
    name            = mode
    description     = """Request Command.

The configure command set the overall correction mode of the NRTC. On receiving this command the NRTC will stop the NRTC pipeline, via the PIPELINE_STOP command, (re)-configure the AO mode of the RTC.

The command will also configure which detector input streams will be used for low-order correction. These streams are split into tiers as listed below:<ul>
<li> Tier 0 (optional)  PWFS providing TT measurements for acquisition purposes
<li> Tier 1 (required)  single detector that provides LO TTF(A) measurements 
<li> Tier 2 (optional)  1 to 2 detectors that provide LO TT or LO TTF(A) measurements
<li> Tier 3 (optional)  1 to 4 detectors that provide LOT TT measurements
<li> Tier 3F (optional)  single detector that provides LOT TTF measurements
</ul>
The restrictions for Tier assignments are given below:
<ul>
<li> Tier 0 can only be the PWFS
<li> Tier 1 must be either the PWFS or a TTF OIWFS
<li> Tier 2 can be the PWFS or any TT/TTF OIWFS or ODGW
<li> Tier 3 can be any TT OIWFS or ODGW
<li> Tier 3F can only be a TTF OIWFS
<li> a single detector can be assigned to multiple tiers
<li> the same detector cannot be assigned to the same tier twice
<li> the same detector cannot be assigned to both Tier 1 and Tier 2
<li> the same detector cannot be assigned to both Tier 3 and Tier 3F
</ul>
For Tiers 2 and 3, the order in which the detectors are specified defines the order in which the gradients will be assembled for low-order and low-order truth mode reconstruction. If a tier entry is specified as NONE, then that entry is skipped while assembling the low-order gradient vector.

The wavefront corrector rate must be a multiple of the high-order loop rate and the steady-state low-order loop rate. The steady-state low-order loop rate must be a multiple of the steady-state low-order truth loop rate.

Precondition:
<ul>
<li> state.cmd = READY 
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.mode = true
<li> lgsState.enable = {input}
<li> mode.rateHo = {input}
<li> mode.rateLo = {input}
<li> mode.rateLot = {input}
<li> mode.rateWc = {input}
<li> mode.tier1 = {input}
<li> mode.tier2 = {input}
<li> mode.tier3 = {input}
<li> mode.tier3f = {input}
</ul>"""
    args = [
      {
        name        = lgsEnable
        description = "If an enable flag is true then the RTC will use the corresponding pixel stream for high-order correction. For NGS or SL mode, all LGS WFSs should be disabled. The array is ordered LGS WFS [A B C D E F]."
        type        = array
        dimensions: [6]
        items = {
          type      = boolean
        }
      }
      {
        name        = rateHo
        description = "high-order loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1
        units       = Hz 
      }
      {
        name        = rateLo
        description = "low-order loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1 
        units       = Hz
      }
      {
        name        = rateLot
        description = "low-order truth loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1 
        units       = Hz
      }
      {
        name        = rateWc
        description = "wavefront corrector loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1 
        units       = Hz
      }
      {
        name        = oiwfs
        description = "OIWFS mode. The array is ordered OIWFS [A B C]" 
        type        = array
        dimensions: [3]
        items = {
          enum      = [ NONE, TT, TTF ]
        }
      }
      {
        name        = tier1
        description = "Tier 1 detector." 
        enum        = [ PWFS, OIWFSA, OIWFSB, OIWFSC ]
      }
      {
        name        = tier2
        description = "Tier 2 detectors. The array is ordered Tier 2 [A B]"
        type        = array
        dimensions: [2]
        items = {
          enum      = [ NONE, PWFS, OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ]
        }
      }
      {
        name        = tier3
        description = "Tier 3 detectors. The array is ordered Tier 3 [A B C D]"
        type        = array
        dimensions: [4]
        items = {
          enum      = [ NONE, OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ] 
        }
      }
      {
        name        = tier3f
        description = "Tier 3F detector."
        enum        = [ NONE, OIWFSA, OIWFSB, OIWFSC ]
      }
    ]
  }

  {
    name            = simulate
    description     = """Request Command.

At least on input parameter must be specified, all unspecified stages will remain unchanged.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> sim.dm0 = {input dm0}
<li> sim.dm11 = {input dm11}
<li> sim.lgs = {input lgs}
<li> sim.lgsf = {input lgsf}
<li> sim.odgw = {input odgw}
<li> sim.oiwfs = {input oiwfs}
<li> sim.pwfs = {input pwfs}
<li> sim.rpg = {input rpg}
<li> sim.tts = {input tts}
<li> sim.turbulence = {input turbulence}
</ul>"""
    args = [
      {
        name        = dm0 
        description = "Simulated DM0 flag."
        type        = boolean
      }
      {
        name        = dm11 
        description = "Simulated DM11 flag."
        type        = boolean
      }
      {
        name        = lgs 
        description = "Simulated LGS WFS flag. The array is ordered LGS WFS [A B C D E F]."
        type        = array
        dimensions: [6]
        items = {
          type      = boolean
        }
      }
      {
        name        = lgsf 
        description = "Simulated LGSF FSMs flag."
        type        = boolean
      }
      {
        name        = odgw
        description = "Simulated ODGW flag. The array is ordered ODGW [1 2 3 4]."
        type        = array
        dimensions: [4]
        items = {
          type      = boolean
        }
      }
      {
        name        = oiwfs
        description = "Simulated OIWFS flag. The array is ordered OIWFS [A B C]."
        type        = array
        dimensions: [3]
        items = {
          type      = boolean
        }
      }
      {
        name        = pwfs 
        description = "Simulated PWFS flag."
        type        = boolean
      }
      {
        name        = rpg 
        description = "Simulated RPG flag."
        type        = boolean
      }
      {
        name        = tts 
        description = "Simulated TTS flag."
        type        = boolean
      }
      {
        name        = turbulence  
        description = "Simulated turbulence flag."
        type        = boolean
      }
    ]
  }


 {
    name            = calibLgsBackground
    description     = """Submit Command.

This command instructs the NRTC to take new normalized LGS WFS sky & instrument background and/or save the background to the TMT Configuration Service. This command applies to all enabled LGS WFSs.

If the number of frames to average is specified then the NRTC will average the specified number of frames to measure the current backgrounds. The current detector backgrounds, specified in the configuration file, are subtracted from the measured backgrounds to produce the sky & instrument backgrounds. These sky & instrument backgrounds are then normalized to a 1 second exposure and stored as the current normalized LGS WFS sky & instrument backgrounds in the NRTC, as which point the command returns. Subsequent call to this command will replace the normalized sky & instrument backgrounds and calls to the init command will reset all backgrounds to the defaults specified in the configuration file.

If the sky configuration name input parameter is specified, then the NRTC will save the current normalized sky & instrument backgrounds to the TMT Configuration Service using the configuration name given, after generating a new backgrounds if instructed to do so (i.e. number of frames to average is specified). Note that the configuration file will only contain the normalized sky & instrument backgrounds, and should be different from the configuration name used by the init command.

If neither input argument is specified, then this command will return with an error.

If pixels are not received from all enabled LGS WFSs in a timely manner, then this command will return with an error and no backgrounds will be updated or saved.

Discussion: It is assumed that the lasers will be detuned before executing this command so the sky & instrument backgrounds will include Rayleigh backscattering.

Precondition:
<ul>
<li> state.cmd = READY 
<li> state.mode = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
    args = [
      {
        name        = avg
        description = "number of frames to average"
        type        = integer
        minimum     = 0 
      }
      {
        name        = skyConfig
        description = "name of sky configuration file to save the current sky image to in the configuration service."
        type        = string
      }
    ]
  }

  {
    name            = calibModePixel
    description     = """Request Command.

This command sets which raw pixel data are sent directly to the RPG for calibration purposes. 

In CONTINIOUS mode the NRTC will continually stream (averaged) pixel frames to the RPG. The STOP mode will stop pixel frames from being sent to the RPG. The SINGLE mode will only send the next (averaged) pixel frame to the RPG at which point the pixel mode is reset to STOP. In the WC_SYNC 

The raw pixel averages value indicates the number of frames that will be averaged before the frame is sent to the RPG.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
<li> if {input mode} = WC_SYNC then calibWc.override[{any}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibDetector.pixelAvg[{input detector}] = {input avg}
<li> calibDetector.pixelMode[{input detector}] = {input mode}
<li> calibDetector.pixelDelay[{input detector}] = {input delay}
</ul>"""
    args = [
      {
        name        = detector  
        description = "indicates which detector pixel calibration mode to set."
        enum        = [LGSWFS ODGW OIWFS PWFS ALL]
      }
      {
        name        = mode
        description = "raw pixel calibration mode"
        enum        = [ STOP, SINGLE, CONTINUOUS, WC_SYNC ]
      }
      {
        name        = avg
        description = "number of pixel frames to average before sending to the RPG. This argument must be specified is the mode is set to SINGLE, CONTINUOUS or WC_SYNC."
        type        = integer
        minimum     = 0 
      }
      {
        name        = delay
        description = "number of pixel frames to delay (skip) before the starting to average pixel frames, after a WC override command has been applied. This argument must specified only when the mode is set to WC_SYNC. If an additional WC override command is received and applied before this delay time has elapsed, then the delay counter is reset. If a WC override command is not received after the mode is set to  WC_SYNC or the WC override commands are disabled, then no averaged pixels will be returned."
        type       = integer
        minimum    = 0
      }
    ]
    requiredArgs = [ detector, mode ] 
  }

 {
    name            = calibModeGrad
    description     = """Request Command.

This command sets which gradients are sent directly to the RPG for calibration purposes.
 
This command works similarly to calibModePixel command, except instead of operating on raw pixels, this command operates on gradients, averaging the gradients from the specified detector and then sending that average to the RPG.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibDetector.gradAvg[{input detector}] = {input avg}
<li> calibDetector.gradMode[{input detector}] = {input mode}
<li> calibDetector.gradDelay[{input detector}] = {input delay}
</ul>"""
    args = [
      {
        name        = detector  
        description = "indicates which detector gradient calibration mode to set."
        enum        = [LGSWFS ODGW OIWFS PWFS ALL]
      }
      {
        name        = mode
        description = "gradient calibration mode"
        enum        = [ STOP, SINGLE, CONTINUOUS, WC_SYNC ]
      }
       {
        name        = avg
        description = "number of gradient frames to average before sending to the RPG. This argument must be specified is the mode is set to SINGLE, CONTINUOUS or WC_SYNC."
        type        = integer
        minimum     = 0 
      }
      {
        name        = delay
        description = "number of gradient frames to delay (skip) before the starting to average gradient frames, after a WC override command has been applied. (see calibModePixel command for more details)."
        type       = integer
        minimum    = 0
      }

    ]
    requiredArgs = [ detector, mode ] 
  }


  {
    name            = calibModeCmd
    description     = """Request Command.

This command sets what DM and TTS commands are sent directly to the RPG. This command is intended for system flat calibration purposes.
 
This command works similarly to calibModePixel command, except instead of operating on raw  pixels, this command operates on DM and TTS commands, averaging the command sent to either the DM and TTS and then sending that average to the RPG.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibWc.avg[{input wc}] = {input avg}
<li> calibWc.mode[{input wc}] = {input mode}
</ul>"""
    args = [
      {
        name        = wc  
        description = "indicates which wavefront corrector command calibration mode to set."
        enum        = [DM0 DM11 TTS ALL]
      }
      {
        name        = mode
        description = "command calibration mode"
        enum        = [ STOP, SINGLE, CONTINUOUS ]
      }
      {
        name        = avg
        description = "number of command frames to average before sending to the RPG. This argument must be specified is the mode is set to SINGLE or CONTINUOUS."
        type        = integer
        minimum     = 0 
      }

    ]
    requiredArgs = [ wc, mode ] 
  }

 {
    name            = calibModeWc
    description     = """Request Command.

This command puts the NRTC wavefront controller into a calibration mode where the DMs or TTS can be adjusted directly by the RPG. This command is intended for calibration purposes. While in this calibrate mode, the  DMs and/or TTS are not updated by their normal path in the NRTC pipeline, but instead they listen for update streams directly from the RPG. While not in calibrate mode, any related update from the RPG is ignored. This command will be rejected if the high or low-order loop is closed.

<p>
Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
<li> loop.ho = IDLE
<li> loop.lo = IDLE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibWc.override[{input wc}] = {input override}
</ul>"""
    args = [
         {
        name        = wc  
        description = "indicates which wavefront corrector command override mode to set."
        enum        = [DM0 DM11 TTS ALL]
      }
      {
        name        = mode
        description = "command override mode"
        type        = boolean
      }
    ]
    requiredArgs = [ wc, mode ] 
  }




]

