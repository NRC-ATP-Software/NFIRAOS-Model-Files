subsystem = NFIRAOS
component = rtc

description = NRTC Assembly commands.

receive = [
  {
    name            = init
    description     = """Request Command.

The initialize command restores NRTC software to the state immediately after a boot-up. This command the stops the NRTC pipeline, via the pipelineStop command, and will reset all internal states to default values, clear any mode configuration parameters and then request the specified configuration file from the TMT Configuration Service. Upon receiving the configuration file from the TMT configuration service, the NRTC will parse the configuration data and load it into memory. After the configuration file has been read, the NRTC will (re-)establishes communication with the RPG. An equivalent result to this command can be achieved by restarting all NRTC software.

Discussion: There should be a convention to tell the NRTC to use a local version of the configure file(s) for engineering/integration purposes when the TMT configuration service is not yet available. This could be embedded in the configuration name/version.

Precondition:
<ul>
<li> none
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.mode = false
<li> config.name = {input}
<li> config.version = {input}
<li> all other internal parameters set to default values
</ul>"""
    args = [
      {
        name        = configName 
        description = Name of the configuration file to get from the TMT Configuration Service
        type        = string
      }
      {
        name        = configVersion
        description = Version of the configuration file to get from the TMT Configuration Service
        type        = string 
      }
    ]
  }  

  {
    name            = mode
    description     = """Request Command.

The configure command set the overall correction mode of the NRTC. On receiving this command the NRTC will stop the NRTC pipeline, via the pipelineStop command, (re)-configure the AO mode of the RTC.

The command will also configure which detector input streams will be used for low-order correction. These streams are split into tiers as listed below:
<ul>
<li> Tier 0 (optional)  PWFS providing TT measurements for acquisition purposes
<li> Tier 1 (required)  single detector that provides LO TTF(A) measurements 
<li> Tier 2 (optional)  1 to 2 detectors that provide LO TT or LO TTF(A) measurements
<li> Tier 3 (optional)  1 to 4 detectors that provide LOT TT measurements
<li> Tier 3F (optional)  single detector that provides LOT TTF measurements
</ul>
The restrictions for Tier assignments are given below:
<ul>
<li> Tier 0 can only be the PWFS
<li> Tier 1 must be either the PWFS or a TTF OIWFS
<li> Tier 2 can be the PWFS or any TT/TTF OIWFS or ODGW
<li> Tier 3 can be any TT OIWFS or ODGW
<li> Tier 3F can only be a TTF OIWFS
<li> a single detector can be assigned to multiple tiers
<li> the same detector cannot be assigned to the same tier twice
<li> the same detector cannot be assigned to both Tier 1 and Tier 2
<li> the same detector cannot be assigned to both Tier 3 and Tier 3F
</ul>

For Tiers 2 and 3, the order in which the detectors are specified defines the order in which the gradients will be assembled for low-order and low-order truth mode reconstruction. If a tier entry is specified as NONE, then that entry is skipped while assembling the low-order gradient vector.

The wavefront corrector rate must be a multiple of the high-order loop rate and the steady-state low-order loop rate. The steady-state low-order loop rate must be a multiple of the steady-state low-order truth loop rate.

Any OIWFS that is assigned to Tier 1 or Tier 3F must be set to TTF mode, while any OIWFS that is assigned to Tier 2 or Tier 3 can be either set to TT or TTF mode. All OIWFSs not assigned to a low-order tier must be set to the NONE mode.

Precondition:
<ul>
<li> state.cmd = READY 
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.mode = true
<li> mode.rateHo = {input rateHo}
<li> mode.rateLo = {input rateLo}
<li> mode.rateLot = {input rateLot}
<li> mode.rateWc = {input rateWc}
<li> mode.tier1 = {input tier1}
<li> mode.tier2[] = {input tier2}
<li> mode.tier3[] = {input tier3}
<li> mode.tier3f = {input tier3f}
<li> lgsState.enable[] = {input lgsEnable}
<li> oiwfsState.enable[] = {input oiwfs}
<li> if {input lgsEnable[*] == false}, then loop.lgsTt[*] = INACTIVE
<li> if {input tier2[] != ODGW* and input tier3[] != ODGW*}, 
  <ul>
  <li> then odgwState.enable[ODGW*] = false
  <li> else odgwState.enable[ODGW*] = true
  </ul>
<li> if {input tier2[*] == NONE}, then loop.tier2[*] = INACTIVE
<li> if {input tier3[*] == NONE}, then loop.tier3[*] = INACTIVE
<li> if {input tier3f == NONE}, then loop.tier3f = INACTIVE
<li> if {input tier1 != OIWFS* and input tier2[] != OIWFS*}, then loop.oiwfsPoa[OIWFS*] = INACTIVE
</ul>"""o
    args = [
      {
        name        = lgsEnable
        description = "If an enable flag is true then the RTC will use the corresponding pixel stream for high-order correction. For NGS or SL mode, all LGS WFSs should be disabled. The array is ordered LGS WFS [A B C D E F]."
        type        = array
        dimensions: [6]
        items = {
          type      = boolean
        }
      }
      {
        name        = rateHo
        description = "high-order loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1
        units       = Hz 
      }
      {
        name        = rateLo
        description = "low-order loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1 
        units       = Hz
      }
      {
        name        = rateLot
        description = "low-order truth loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1 
        units       = Hz
      }
      {
        name        = rateWc
        description = "wavefront corrector loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1 
        units       = Hz
      }
      {
        name        = oiwfs
        description = "OIWFS mode. The array is ordered OIWFS [A B C]" 
        type        = array
        dimensions: [3]
        items = {
          enum      = [ NONE, TT, TTF ]
        }
      }
      {
        name        = tier1
        description = "Tier 1 detector." 
        enum        = [ PWFS, OIWFSA, OIWFSB, OIWFSC ]
      }
      {
        name        = tier2
        description = "Tier 2 detectors. The array is ordered Tier 2 [A B]"
        type        = array
        dimensions: [2]
        items = {
          enum      = [ NONE, PWFS, OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ]
        }
      }
      {
        name        = tier3
        description = "Tier 3 detectors. The array is ordered Tier 3 [A B C D]"
        type        = array
        dimensions: [4]
        items = {
          enum      = [ NONE, OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ] 
        }
      }
      {
        name        = tier3f
        description = "Tier 3F detector."
        enum        = [ NONE, OIWFSA, OIWFSB, OIWFSC ]
      }
    ]
  }

  {
    name            = stop
    description     = """Request Command.

This command will open all loops, via the loopOpen command, and abort the processing of an active submit command.

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.lgsBackgroud = false
</ul>"""
  }

  {
    name            = simulate
    description     = """Request Command.

At least on input parameter must be specified, all unspecified stages will remain unchanged.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> sim.dm0 = {input dm0}
<li> sim.dm11 = {input dm11}
<li> sim.lgs = {input lgs}
<li> sim.lgsf = {input lgsf}
<li> sim.odgw = {input odgw}
<li> sim.oiwfs = {input oiwfs}
<li> sim.pwfs = {input pwfs}
<li> sim.rpg = {input rpg}
<li> sim.tts = {input tts}
<li> sim.turbulence = {input turbulence}
</ul>"""
    args = [
      {
        name        = dm0 
        description = "Simulated DM0 flag."
        type        = boolean
      }
      {
        name        = dm11 
        description = "Simulated DM11 flag."
        type        = boolean
      }
      {
        name        = lgs 
        description = "Simulated LGS WFS flag. The array is ordered LGS WFS [A B C D E F]."
        type        = array
        dimensions: [6]
        items = {
          type      = boolean
        }
      }
      {
        name        = lgsf 
        description = "Simulated LGSF FSMs flag."
        type        = boolean
      }
      {
        name        = odgw
        description = "Simulated ODGW flag. The array is ordered ODGW [1 2 3 4]."
        type        = array
        dimensions: [4]
        items = {
          type      = boolean
        }
      }
      {
        name        = oiwfs
        description = "Simulated OIWFS flag. The array is ordered OIWFS [A B C]."
        type        = array
        dimensions: [3]
        items = {
          type      = boolean
        }
      }
      {
        name        = pwfs 
        description = "Simulated PWFS flag."
        type        = boolean
      }
      {
        name        = rpg 
        description = "Simulated RPG flag."
        type        = boolean
      }
      {
        name        = tts 
        description = "Simulated TTS flag."
        type        = boolean
      }
      {
        name        = turbulence  
        description = "Simulated turbulence flag."
        type        = boolean
      }
    ]
  }


 {
    name            = calibLgsBackground
    description     = """Submit Command.

This command instructs the NRTC to take new normalized LGS WFS sky & instrument background and/or save the background to the TMT Configuration Service. This command applies to all enabled LGS WFSs.

If the number of frames to average is specified then the NRTC will average the specified number of frames to measure the current backgrounds. The current detector backgrounds, specified in the configuration file, are subtracted from the measured backgrounds to produce the sky & instrument backgrounds. These sky & instrument backgrounds are then normalized to a 1 second exposure and stored as the current normalized LGS WFS sky & instrument backgrounds in the NRTC, as which point the command returns. Subsequent call to this command will replace the normalized sky & instrument backgrounds and calls to the init command will reset all backgrounds to the defaults specified in the configuration file.

If the sky configuration name input parameter is specified, then the NRTC will save the current normalized sky & instrument backgrounds to the TMT Configuration Service using the configuration name given, after generating a new backgrounds if instructed to do so (i.e. number of frames to average is specified). Note that the configuration file will only contain the normalized sky & instrument backgrounds, and should be different from the configuration name used by the init command.

If neither input argument is specified, then this command will return with an error.

If pixels are not received from all enabled LGS WFSs in a timely manner (TBD), then this command will return with an error and no backgrounds will be updated or saved.

A call to the stop command will abort this process.

Discussion: It is assumed that the lasers will be detuned before executing this command so the sky & instrument backgrounds will include Rayleigh backscattering.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
<li> state.lgsBackgroud = true
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.lgsBackgroud = false
<li> if {input skyConfig not specified}, then state.unsavedLgsSky = true
<li> if {input skyConfig is specified}, then state.unsavedLgsSky = false
<li> if {input skyConfig is different from current LGS sky config file}, then state.unsavedConfig = true
</ul>"""
    args = [
      {
        name        = avg
        description = "number of frames to average"
        type        = integer
        minimum     = 0 
      }
      {
        name        = skyConfig
        description = "name of sky configuration file to save the current sky image to in the configuration service."
        type        = string
      }
    ]
  }

  {
    name            = calibModePixel
    description     = """Request Command.

This command sets which raw pixel data are sent directly to the RPG for calibration purposes. 

In CONTINIOUS mode the NRTC will continually stream (averaged) pixel frames to the RPG. The STOP mode will stop pixel frames from being sent to the RPG. The SINGLE mode will only send the next (averaged) pixel frame to the RPG at which point the pixel mode is reset to STOP. In the WC_SYNC mode average process will be delayed by the specified number of pixel frames after a WC override command has been applied. If an additional WC override command is received and applied before this delay has elapsed, then the delay is reset. 

The raw pixel averages value indicates the number of frames that will be averaged before the frame is sent to the RPG.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibDetector.pixelAvg[{input detector}] = {input avg}
<li> calibDetector.pixelMode[{input detector}] = {input mode}
<li> calibDetector.pixelDelay[{input detector}] = {input delay}
</ul>"""
    args = [
      {
        name        = detector  
        description = "indicates which detector pixel calibration mode to set."
        enum        = [LGSWFS ODGW OIWFS PWFS ALL]
      }
      {
        name        = mode
        description = "raw pixel calibration mode"
        enum        = [ STOP, SINGLE, CONTINUOUS, WC_SYNC ]
      }
      {
        name        = avg
        description = "number of pixel frames to average before sending to the RPG. This argument must be specified is the mode is set to SINGLE, CONTINUOUS or WC_SYNC."
        type        = integer
        minimum     = 0 
      }
      {
        name        = delay
        description = "number of pixel frames to delay (skip) before the starting to average pixel frames, after a WC override command has been applied. This argument must specified only when the mode is set to WC_SYNC. If an additional WC override command is received and applied before this delay time has elapsed, then the delay counter is reset. If a WC override command is not received after the mode is set to WC_SYNC or the WC override commands are disabled, then no averaged pixels will be returned."
        type       = integer
        minimum    = 0
      }
    ]
    requiredArgs = [ detector, mode ] 
  }

 {
    name            = calibModeGrad
    description     = """Request Command.

This command sets which gradients are sent directly to the RPG for calibration purposes.
 
This command works similarly to calibModePixel command, except instead of operating on raw pixels, this command operates on gradients, averaging the gradients from the specified detector and then sending that average to the RPG.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibDetector.gradAvg[{input detector}] = {input avg}
<li> calibDetector.gradMode[{input detector}] = {input mode}
<li> calibDetector.gradDelay[{input detector}] = {input delay}
</ul>"""
    args = [
      {
        name        = detector  
        description = "indicates which detector gradient calibration mode to set."
        enum        = [LGSWFS ODGW OIWFS PWFS ALL]
      }
      {
        name        = mode
        description = "gradient calibration mode"
        enum        = [ STOP, SINGLE, CONTINUOUS, WC_SYNC ]
      }
       {
        name        = avg
        description = "number of gradient frames to average before sending to the RPG. This argument must be specified is the mode is set to SINGLE, CONTINUOUS or WC_SYNC."
        type        = integer
        minimum     = 0 
      }
      {
        name        = delay
        description = "number of gradient frames to delay (skip) before the starting to average gradient frames, after a WC override command has been applied. (see calibModePixel command for more details)."
        type       = integer
        minimum    = 0
      }

    ]
    requiredArgs = [ detector, mode ] 
  }


  {
    name            = calibModeCmd
    description     = """Request Command.

This command sets what DM and TTS commands are sent directly to the RPG. This command is intended for system flat calibration purposes.
 
This command works similarly to calibModePixel command, except instead of operating on raw  pixels, this command operates on DM and TTS commands, averaging the command sent to either the DM and TTS and then sending that average to the RPG.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibWc.avg[{input wc}] = {input avg}
<li> calibWc.mode[{input wc}] = {input mode}
</ul>"""
    args = [
      {
        name        = wc  
        description = "indicates which wavefront corrector command calibration mode to set."
        enum        = [DM0 DM11 TTS ALL]
      }
      {
        name        = mode
        description = "command calibration mode"
        enum        = [ STOP, SINGLE, CONTINUOUS ]
      }
      {
        name        = avg
        description = "number of command frames to average before sending to the RPG. This argument must be specified is the mode is set to SINGLE or CONTINUOUS."
        type        = integer
        minimum     = 0 
      }

    ]
    requiredArgs = [ wc, mode ] 
  }

 {
    name            = calibModeWc
    description     = """Request Command.

This command puts the NRTC wavefront controller into a calibration mode where the DMs or TTS can be adjusted directly by the RPG. This command is intended for calibration purposes. While in this calibrate mode, the  DMs and/or TTS are not updated by their normal path in the NRTC pipeline, but instead they listen for update streams directly from the RPG. While not in calibrate mode, any related update from the RPG is ignored. This command will be rejected if the high or low-order loop is closed.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
<li> loop.ho = IDLE
<li> loop.lo = IDLE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibWc.override[{input wc}] = {input override}
</ul>"""
    args = [
         {
        name        = wc  
        description = "indicates which wavefront corrector command override mode to set."
        enum        = [DM0 DM11 TTS ALL]
      }
      {
        name        = mode
        description = "command override mode"
        type        = boolean
      }
    ]
    requiredArgs = [ wc, mode ] 
  }


  {
    name            = pipelineStart
    description     = """Request Command.

This command (re)initializes the NRTC pipeline by starting pixel processing, including gradient computation using CoG, and will flattening the DMs, via the dmFlatten command, zero the TTS, via the ttsZero command, zero the LGS FSMs, via the lgsfFsmZero command, and resetting integrators and filters, via the loopParamReset command. Subsequent calls to this command will re-initialize the pipeline, opening all loops, via the loopOpen command, then resetting parameters and flattening/zeroing controlled elements.

Note that published control loop specific telemetry or telemetry sent directly to the RPG will not be started with this command, and will begin once the corresponding loop is closed. 

Discussion: It is anticipated that pixel reading will always occur as long as the NRTC software is running; it is therefore unaffected by this command.

Precondition:
<ul>
<li> state.cmd = READY 
<li> state.mode = true
<li> state.rpgDate = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> calibWc.override[] = false
<li> lgsState.algo = COG_STATIC | NONE
<li> pwfsState.algo = COG_STATIC
<li> odgwState.algo[] = COG_STATIC | NONE
<li> oiwfsState.algo[] = COG_STATIC | NONE
</ul>"""
  }

  {
    name            = pipelineStop
    description     = """Request Command.

This command stops the NRTC pipeline, i.e. stopping all closed-loop processing via the loopOpen command, and stopping pixel processing. This command is intended to shut down the NRTC data processing, i.e. at the end of a night. However, it leaves the software in a state whereby the NRTC continues to respond to commands, and the pipeline can easily be restarted.

Discussion: It is anticipated that pixel reading will always occur as long as the NRTC software is running; it is therefore unaffected by this command. However, any pixels read while in this state are simply stored in the RTC Telemetry Storage System, and there will be no further processing.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
<li> calibDetector.pixelMode[] = STOP
<li> calibDetector.gradMode[] = STOP
<li> calibWc.mode[] = STOP
<li> calibWc.override[] = false
<li> lgsState.algo = NONE
<li> pwfsState.algo = NONE
<li> odgwState.algo[] = NONE
<li> oiwfsState.algo[] = NONE
</ul>"""
  }


  {
    name            = loopOpen
    description     = """Request Command.

This command opens all control loops and offloading in the RTC.

 Note that this command does not reset the integrator or filter states; use the pipelineStart or loopParamReset command to reset those parameters.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.ho = IDLE
<li> loop.lgsFocus = IDLE
<li> loop.lgsDither = NONE
<li> loop.lgsTt[] = IDLE | INACTIVE
<li> loop.lo = IDLE
<li> loop.oiwfsPoa[] = IDLE | INACTIVE
<li> loop.pwfsDither = NONE
<li> loop.pwfsSsm = IDLE
<li> loop.twfs = IDLE
<li> loop.tier0 = IDLE
<li> loop.tier1 = IDLE
<li> loop.tier2[] = IDLE | INACTIVE
<li> loop.tier3[] = IDLE | INACTIVE
<li> loop.tier3f = IDLE | INACTIVE
</ul>"""
  }

  {
    name            = loopLgsFocus
    description     = """Request Command.

This command enables or disables the LGS focus loop, which publishing of the LGS trombone offset (lgsFocus) to control the NCC LGS trombone. While the focus error is above LGS focus threshold (from config file) the focus loop state will be ACQUIRE. Once the focus error has dropped below the threshold, the focus loop state will change to LOCK. Note that if the sodium layer estimate, and therefore prepositioning of the LGS trombone, is sufficient, then the initial focus should be below the threshold, and focus loop will be locked immediately. If the LGS focus loop is not IDLE, an enable request will be a no-op.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable} = true, then loop.lgsFocus != IDLE
<li> if {input enable} = false, then loop.lgsFocus = IDLE
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the LGS focus loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLgsTt
    description     = """Request Command.

This command enables or disables the LGS TT loop that sends command to the LGSF to control LGSF FSMs. While the LGS TT error is above the LGS FSM TT threshold (from config file), the FSM TT loop state will be ACQUIRE. Once the TT error has dropped below the threshold the FSM TT loop state will change to LOCK. If the LGS TT loop is not IDLE, an enable request will be a no-op.

The control command will only be applied to the LGSF FSM corresponding to the enabled LGS WFSs (lgsState.enable[]). LGSF FSMs corresponding to disabled LGS WFSs will remain in the IDLE state and will be sent zeros.

Discussion: The acquisition of LGS TT may only take a few frames for the FSMs to move to the correct positions and start guiding. 

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable} = true, then loop.lgsTt[] != IDLE
<li> if {input enable} = false, then loop.lgsTt[] = IDLE | INACTIVE
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the LGS TT loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopTwfs
    description     = """Request Command.

This command enables or disables the TWFS loop which updates the LGS WFS TWFS/MFU reference vector based on PWFS measurements. 

If enabled, the TWFS portion of the TWFS/MFU reference vector is updated based on PWFS measurements. If the TWFS loop is not IDLE, an enable request will be a no-op. Note that the MFU portion of the TWFS/MFU reference vector is updated independently, which is enabled when LGS MF are being built/updated (lgsState.algo = MF_COG | MF_UPDATE). 

Disabling the TWFS loop does not reset the TWFS/MFU reference vector stored in the internal integrator, it merely stops any further TWFS updates from PWFS measurements. To reset the TWFS/MFU reference vector use the command loopParamReset. 

Disabling the TWFS reference vector merely stops the update to the TWFS reference vector and does not impact any other PWFS operation.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then loop.twfs != IDLE
<li> if {input !enable}, then loop.twfs = IDLE
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the TWFS loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopHigh
    description     = """Request Command.

This command enables or disables the high-order loop which applies the high-order correction errors to the control path. While waiting for the loop to stabilize, the high-order loop state will be set to ACQUIRE. Once the loop has stabilized, the high-order loop state will be set to LOCK. If the high-order loop is not IDLE, an enable request will be a no-op.

Disabling the high-order loop does not reset the correction vector stored in the main integrator; it merely stops the high-order error vector. To reset the main integrator use the command loopParamReset. Note that disabling the high-order correction does not interfere with the low-order path.

Discussion: The method we use to determine when the high-order loop is stabilized is TBD. This may entail ramping up the high-order path gain over several frames.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> calibWc.override[] = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then loop.ho != IDLE
<li> if {input !enable}, then loop.ho = IDLE
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the high-order loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLowTier0
    description     = """Request Command.

This command enables or disables Tier 0, the low-order loop using the PWFS to control TT and focus. This command is intended to be used as an optional first step in low-order acquisition.

If the Tier 1 and/or Tier 2 loops are already closed, or is acquiring, this command cannot be executed and will return an error. If either Tier 1 or 2 loops are closed while Tier 0 is active, then a TBD hand-off procedure is triggered and the Tier 0 loop will be opened.

Disabling the Tier 0 loop merely stops the PWFS update of low-order loop and does not impact any other PWFS operation.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.tier1 = IDLE
<li> loop.tier2[] = IDLE | INACTIVE
<li> calibWc.override[] = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then
  <ul>
  <li> loop.lo != IDLE
  <li> loop.tier0 != IDLE
  </ul>
<li> if {input !enable}, then 
  <ul>
  <li> loop.lo = IDLE
  <li> loop.tier0 = IDLE
  </ul>
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the Tier 0 loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }


  {
    name            = loopLowTier1
    description     = """Request Command.

This command enables or disables the low-order loop which applies low-order correction errors to the control path from the Tier 1 detector, i.e. the LO TTF detector. Enabling this loop triggers the Tier 1 acquisition process that steps through the Tier 1 acquisition table. While stepping through this table, the Tier 1 loop state is set to ACQUIRE. Once the acquisition process is complete the state is set to LOCK.

If the Tier 0 loop is closed, then a TBD hands-off procedure is performed to transition TTF control from the PWFS to the Tier 1 detector. If the PWFS is the Tier 1 detector, then this hands-off procedure is a no-op. 

If enabled, and the Tier 1 detector is already acquiring or locked, this command is a no-op. Additionally, if the Tier 1 detector is the PWFS then the ACQUIRE state is skipped since the PWFS does not have an acquisition procedure. If the PWFS is configured as the Tier 1 detector, disabling Tier 1 merely stops the PWFS control in the low-order path and does not impact any other PWFS operation.

Disabling Tier 1 will also disable Tier 3. 

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> calibWc.override[] = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then
  <ul>
  <li> loop.lo != IDLE
  <li> loop.tier0 = IDLE
  <li> loop.tier1 != IDLE
  </ul>
<li> if {input !enable}, then 
  <ul>
  <li> loop.tier1 = IDLE
  <li> loop.tier3[] = IDLE | INACTIVE
  <li> loop.tier3f = IDLE | INACTIVE
  </ul>
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the Tier 1 loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLowTier2
    description     = """Request Command.

This command enables or disables the low-order loop which apples low-order correction errors to the control path from the Tier 2 detectors, i.e. the LO TT/TTF detectors. Enabling this loop triggers the Tier 2 acquisition process that steps through the Tier 2 acquisition tables. While stepping through these tables, the Tier 2 loop is set to ACQUIRE. Once the acquisition process is complete the state is set to LOCK. 

If enabling the Tier 2 loop but the detector is inactive (mode.tier2[] = NONE), then that detector is skipped and the corresponding Tier 2 state will be INACTIVE. If a Tier 2 detector is already acquiring or locked, this command is a no-op for that detector and will proceed to the next Tier 2 detector.

If the Tier 0 loop is closed, then a TBD hands-off procedure is performed to transition TT/TTF control from the PWFS to the Tier 2 detector(s). If the PWFS is the Tier 2 detector, then this hands-off procedure is a no-op and will proceed to the next Tier 2 detector. If PWFS in configured as a Tier 2 detector then disabling Tier 2 merely stops the PWFS control in the low-order path, and does not impact any other PWFS operation.

Disabling Tier 2 will also disable Tier 3.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> calibWc.override[] = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then
  <ul>
  <li> if {at least one mode.tier2[] != NONE}, then loop.lo != IDLE
  <li> loop.tier0 = IDLE
  <li> loop.tier2[] != IDLE
  </ul>
<li> if {input !enable}, then 
  <ul>
  <li> loop.tier2[] = IDLE | INACTIVE
  <li> loop.tier3[] = IDLE | INACTIVE
  <li> loop.tier3f = IDLE | INACTIVE
  </ul>
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the Tier 1 loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLowTier3
    description     = """Request Command.

This command enables or disables the low-order loop which applies low-order correction errors to the control path from the Tier 3 and Tier 3F detectors, i.e., the LOT detectors. Enabling this loop triggers the Tier 3 and Tier 3F acquisition process that steps through the acquisition tables. While stepping through these tables, the Tier 3 loop state is set to ACQUIRE. Once the acquisition process has been completed the state is set to LOCK. 

Tier 3 can only be closed after Tier 1 and all active Tier 2 loops have been started, however Tier 3 acquisition will not start until after Tier 1 & 2 detectors have completed their acquisition (loop.tier1 = LOCK and loop.tier2[] = LOCK | INACTIVE). Therefore, if there are no active Tier 2 detectors, only Tier 1 must be acquired before closing Tier 3 loops.

If enabling is requested and a Tier 3 or 3F detector is inactive (mode.tier3[] = NONE or mode.tier3f = NONE), that detector is skipped and the corresponding Tier state will be INACTIVE. If a Tier 3 detector is already acquiring or locked, this command is a no-op for that senor and will proceed to the next Tier 3 detector.

Enabling the Tier 3 loo will set the LO path filter to a high-pass filter, and the LOT path filter to a low-pass filter. Conversely, disabling Tier 3 will set the low-order mode filter to an all-pass filter, and the low-order truth filter to be an all-stop filter.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.tier1 != IDLE
<li> loop.tier2[] != IDLE
<li> calibWc.override[] = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then
  <ul>
  <li> loop.lo != IDLE
  <li> loop.tier3[] != IDLE
  <li> loop.tier3f != IDLE
  </ul>
<li> if {input !enable}, then 
  <ul>
  <li> loop.lo != IDLE
  <li> loop.tier3[] = IDLE | INACTIVE
  <li> loop.tier3f = IDLE | INACTIVE
  </ul>
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the Tier 3 loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLgsDither
    description     = """Request Command.

This command enables or disables LGS dithering. 

If non-common path (NCP) dithering is selected, then the NRTC applies the LGS dither signal applied to the LGSF FSM. The LGS dither signal is added to the LGSF FSM commands generated by the LGS TT loop (see the loopLgsTt command). If the LGS TT loop is stopped (loop.lgsTt[] = IDLE) before or during the application of the LGS dither signal, the dither signal is added to the current LGSF FSM command, as stored in the FSM integrator or Kalman filter. The dither signal will only be applied to the LGSF FSM corresponding to the enabled LGS WFSs (lgsState.enable[]).

If common path (CP) dithering is selected, then the CP LGS dither signal (tip/tilt) is applied to DM0. The CP dither signal is applied to the actuator commands generated by the wavefront corrector. If the High and Low-Order loops are stopped (loop.ho = IDLE and loop.lo = IDLE) before or during the application of the CP LGS dither signal, the dither signal is superimposed on the current DM0 shape, as stored in the main wavefront corrector integrator. This dither signal is completely independent of the PWFS dither signal described in the loopPwfsDither command.

If either NCP or CP dithering is enabled, the LGS matched filter optimization is started. If at any point the LGS pixel processing does not have a set of matched filters (lgsState.mf = false), then it will initially use CoG (lgsState.algo = MF_COG) and once a set of matched filters has been computed (lgsState.mf = true) then they will be applied to the pixel processing (lgsState.algo = MF_UPDATE). If a set of matched filters is available (lgsState.mf = true) when the dither signal is enabled, then they will be used immediately (lgsState.algo = MF_UPDATE). The current set of matched filters can be cleared by the loopParamRest command.

Enabled LGS dithering also triggers the updating of the MFU portion of the TWFS/MFU reference vector.

If NONE is selected, then the NRTC will not dither DM0 or LGSF FSMs, and LGS pixel processing will continue to use the latest set of matched filters (lgsState.algo = MF_STATIC). To revert back to CoG the algoSetLgs command can be used.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.lgsDither = {input enable}
<li> if {input enable != NONE}, then lgsState.algo = MF_COG | MF_UPDATE
<li> if {input enable == NONE}, then lgsState.algo = MF_STATIC 
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the LGS Dithering loop"
        enum        = [ CP, NCP, NONE ]
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopPwfsDither
    description     = """Request Command.

This command enables or disables PWFS dithering. 

If non-common path (NCP) dithering is selected, then the NRTC assumes that NCC has, or will, be instructed to dither the NGS FSM. The NRTC will then listen to the NGS FSM sensed position stream from the NCC and estimate the dither signal for optimization and removal from the PWFS gradients.

If common path (CP) dithering is selected, then the CP PWFS dither signal is applied to DM0. The CP dither signal is applied to the actuator commands generated by the wavefront corrector. If the High and Low-Order loops are stopped (loop.ho=IDLE & loop.lo=IDLE) before or during the application of the CP dither signal, the dither signal is superimposed on the current DM0 shape, as stored in the main wavefront corrector integrator. This dither signal is completely independent of the LGS dither signal described in the loopLgsDither command.

If either NCP or CP dithering is enabled, the PWFS optical gain optimization is started.

If NONE is selected, then the NRTC will not dither DM0 and will ignore the NGS FSM position stream, and the optical gain optimization is stopped, however the current value of the optic gain is held. To reset the optical gain the loopParamRest command can be used.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.pwsfDither = {input enable}
<li> if {input enable != NONE}, then pwfsState.algo = GOG_UPDATE
<li> if {input enable == NONE}, then pwfsState.algo = COG_STATIC
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the PWFS Dithering loop"
        enum        = [ CP, NCP, NONE ]
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = algoSetLgs
    description     = """Request Command.

This command sets the LGS gradient computation algorithm for engineering purposes.

When the LGS algorithm is set to COG_STATIC, the LGS gradients will be generated using center of gravity. This is the default state after starting the pipeline, via the pipelineStart command, but prior to starting matched filter optimization, via the loopLgsDither command.

When the LGS algorithm is set to MF_STATIC, the LGS gradients will be generated using the current matched filters however will not updated the current matched filters. If no matched filters have been built yet, or have been cleared via a command like loopParamReset, then this command will return an error.

When the LGS algorithm is set to CUSTOM, the TBD...

Note that this command does not clear the current LGS matched filters.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.lgsDither = NONE
<li> lgsState.enable[{at least one}] = true
<li> if {input algo == MF_STATIC} then lgsState.mf = true 
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> lgsState.algo = {input algo} 
</ul>"""
    args = [
      {
        name        = algo  
        description = ""
        enum        = [ COG_STATIC, MF_STATIC, CUSTOM ]
      }
    ]
    requiredArgs = [ algo ] 
  }

 {
    name            = algoSetPwfs
    description     = """Request Command.

This command sets the PWFS gradient computation algorithm for engineering purposes.

When the PWFS algorithm is set to BP, the PWFS gradients will be generated using the brightest pixel. 

When the PWFS algorithm is set to COG_STATIC, the PWFS gradients will be generated using center of gravity. This is the default state after starting the pipeline, via the pipelineStart command, but prior to starting optical gain optimization, via the loopPwfsDither command.

When the PWFS algorithm is set to CUSTOM, the TBD...

Note that this command does not (re)set the PWFS optical gain value.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.pwfsDither = NONE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> pwfsState.algo[] = {input algo}
</ul>"""
    args = [
      {
        name        = algo  
        description = ""
        enum        = [ COG_STATIC, BP, CUSTOM ]
      }
    ]
    requiredArgs = [ algo ] 
  }

 {
    name            = algoOverrideOiwfsOdgw
    description     = """Request Command.

This command override the OIWFS/ODGW gradient algorithms specified in the acquisition table. 

When the OIWFS/ODGW algorithm is set to TABLE, the OIWFS/ODGW gradients will be generated using the algorithm specified in the current step of the current acquisition table (either the guiding or dithering table, depending on the telescope dither state). This is the default mode of operation for the RTC. If the acquisition process has not been started or the corresponding loop has been opened, then CoG will be used (oiwfs/odgwState.algo[] = COG_STATIC). When an OIWFS/ODGW algorithm is set to anything other than TABLE, the gradients algorithm is overridden by the selection and the algorithms specified in the acquisition tables are ignored until OIWFS/ODGW algorithm is set back to TABLE.

When the OIWFS/ODGW algorithm is set to BP, the OIWFS/ODGW gradients will be generated using the brightest pixel. 

When the OIWFS/ODGW algorithm is set to GOG_STATIC, the OIWFS/ODGW gradients will be generated using center of gravity (CoG).

When the OIWFS/ODGW algorithm is set to MF_STATIC, the OIWFS/ODGW gradients will be generated using the current matched filters however will not updated the current matched filters. If no matched filters have been produced or set yet, or have been cleared via a command like loopParamReset, then this command will return an error.

When the OIWFS/ODGW algorithm is set to MF_UPDATE, then OIWFS/ODGW matched filter optimization is started. If at any point the OIWFS/ODGW pixel processing does not have a set of matched filters (oiwfs/odgwState.mf[] = false), then it will initially use CoG (oiwfs/odgwState.algo[] = MF_COG) and once a set of matched filters has been computed (oiwfs/odgwState.mf[] = true) then they will be applied to the pixel processing (oiwfs/odgwState.algo[] = MF_UPDATE). If a set of matched filters is available (oiwfs/odgwState.mf[] = true) the OIWFS/ODGW algorithm is set to MF_UPDATE, then they will be used immediately (oiwfs/odgwState.algo[] = MF_UPDATE). The current set of matched filters can be cleared by the loopParamRest command.

When the OIWFS/ODGW algorithm is set to CUSTOM, the TBD...

Note that this command does not clear the current OIWFS/ODGW matched filters.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> oiwfsState.enable[{input detector}] != NONE 
<li> odgwState.enable[{input detector}] = true
<li> if {input algo == MF_STATIC}, then 
  <ul>
  <li> oiwfsState.mf[{input detector}] = true 
  <li> odgwState.mf[{input detector}] = true 
  </ul>
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input algo == TABLE}, then 
  <ul>
  <li> oiwfsState.algo[{input detector}] = {from acquisition table}
  <li> odgwState.algo[{input detector}] = {from acquisition table} 
  </ul>
<li> if {input algo != TABLE}, then 
  <ul>
  <li> oiwfsState.algo[{input detector}] = {input algo} | MF_COG 
  <li> odgwState.algo[{input detector}] = {input algo} | MF_COG 
  </ul>
</ul>"""
    args = [
      {
        name        = detector  
        description = ""
        enum        = [ OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ]
      }
      {
        name        = algo  
        description = ""
        enum        = [ TABLE, COG_STATIC, MF_UPDATE, MF_STATIC, BP, CUSTOM ]
      }
    ]
    requiredArgs = [ algo ] 
  }


 {
    name            = offloadOiwfsPoa
    description     = """Request Command.

This command enables or disables low-order offloading to the OIWFS POAs. POA offload will only be activated for OIWFSs in Tier 1 and 2. 

If enabled, and the OIWFSs have not acquired their guide stars, the acquisition process is started. If the guide stars are already acquired, or are acquiring, as a result of Tiers 1 or 2 being enabled, then the acquisition process is allowed to complete. When enabled the NRTC will publish the POA offloading parameter (oiwfsPoa).

By default the NRTC will wait for OIWFS  acquisition to complete before offloading. However, if the acquisition offload flag (loop.oiwfsOffloadAcq) is set, then offloading begins immediately, even if the acquisition process ongoing. Additionally, offloading will be temporarily halted while dithering.

Disabling the POA offloading merely stops any offloading sent to the POA, and does not impact any other OIWFS operation.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.cmd = READY
<li> if {input enable}, then loop.oiwfsPoa[] != IDLE
<li> if {input !enable}, then loop.oiwfsPoa[] = IDLE | INACTIVE
</ul>"""
  args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the OIWFS POA offloading loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = offloadPwfsSsm
    description     = """Request Command.

This command enables or disables PWFS offloading to the NCC SSM.

When enabled the NRTC will publish the SSM offloading parameter (pwfsSsm).

Disabling the PWFS SSM offloading merely stops any offloading sent to the SSM, and does not impact any other PWFS operation.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then loop.pwfsSsm != IDLE
<li> if {input !enable}, then loop.pwfsSsm = IDLE
</ul>"""
  args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the OIWFS POA offloading loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopParamReset
    description     = """Request Command.

This command will reset one or more loop parameters. If only a parameter name prefix is specified, any parameter with the matching name prefix will be reset. The list of all possible loop parameters that can be reset by this command are: 
<ul>
<li> <b> wc_int </b> - wavefront corrector integrator (= 0)
<li> <b> wc_tt_lpf </b> - TTS filter states (= 0)
<li> <b> wc_tel_lpf	</b> - Telescope offload  high-pass filter states (= 0)
<li> <b> m1Scallop_lpf </b> - M1 Scalloping  high-pass filter states (= 0)
<li> <b> lo_kalman_state </b> - low-order Kalman filter states (= 0)
<li> <b> lo_kalman_avg </b> - low-order Kalman filter mode average feedback (= 0)
<li> <b> lo_mode_hpf </b> - low-order (Tier 1 & 2) high-pass filter states (= 0)
<li> <b> lo_mode_lpf </b> - low-order truth (Tier 3 & 3F) low-pass filter states (= 0)
<li> <b> lo_offload_lpf </b> - POA and SSM offload low-pass filter state (= 0)
<li> <b> pwfs_opticalGain </b> - PWFS optical gain (pwfsState.opticalGain = 1)
<li> <b> lgs_tt_int </b> - LGSF FSM integrator (= 0)
<li> <b> lgs_tt_kalman </b> - LGSF FSM Kalman filter states (= 0)
<li> <b> lgs_mf </b> - LGS matched filters (lgsState.mf = false)
<li> <b> lgs_focus_lpf </b> - LGS focus low-pass filter states (= 0)
<li> <b> lgs_twfs_int </b>	- TWFS/MFU reference vector integrator (= 0)
<li> <b> oiwfs_mf<A..C> </b>	- OIWFS matched filters (oiwfsState.mf[] = false)
<li> <b> odgw_mf<1..4> </b> - ODGW matched filters (odgwState.mf[] = false)
</ul>

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = enable  
        description = "Name or name prefix of the loop parameter to reset. Passing an empty string will reset all loop parameters."
        type        = string
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = configParamSave
    description     = """Request Command.

This command tells the NRTC to save the current parameter configuration to the TMT configuration service using the specified parameter configuration name. 

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.unsavedConfig = false
</ul>"""
  args = [
       {
        name        = config 
        description = Name of the configuration file to save the current parameters to.
        type        = string
      }
    ]
    requiredArgs = [ config ] 
  }

  {
    name            = configParamSet
    description     = """Request Command.

This command tells the NRTC to set the value of any configuration parameter, i.e. a parameter that is specified in the parameter configuration file. The valid parameters for this command are TBD. This command is intended for constructing a new parameter configuration file as well as for engineering and debugging purposes. The NRTC will update the specified parameter, either by value or loading a file that contains the new value. The file format is dependent on the parameter specified and is TBD. Note the new parameter is not automatically saved to the configuration service and will be lost if the init command is called. To signal this condition, the unsaved parameter flag is set. To save the current configuration, use the configParamSave command.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.unsavedConfig = true
</ul>"""
  args = [
       {
        name        = config 
        description = Name of the configuration file to save the current parameters to.
        type        = string
      }
    ]
    requiredArgs = [ config ] 
  }

  {
    name            = paramOverride
    description     = """Request Command.

This command may be removed (TBD).

This command overrides the value of any dynamic parameter, i.e. one that is updated internally by the NRTC or by the RPG, or an event stream. The list of accepted parameters for this command is TBD. This command is intended for engineering and debugging purposes.

If the applyUpdates flag specified in the command is set to FALSE, the NRTC will stop applying updates for the specified parameter, in other words freezing the current value.
Similarly, if a new value is specified, either by the value or filename, the NRTC will stop applying updates and the current value is modified as specified.
 
The NRTC will only resume applying updates for the specified parameter after this command has been called with the applyUdates input flag set to TRUE, or the pipelineStart command has been called.

Exactly one of the value, filename or applyUdates input arguments must be specified.

Discussion: Should there be a published override flag for every possible overridable parameter? 

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input value or filename is specified}, then override.{input name} = true (TBD)
<li> if {input applyUdates is specified}, then override.{input name} = {input !applyUdates} (TBD)
</ul>"""
  args = [
      {
        name        = name 
        description = Name of the dynamic parameter to update
        type        = string
      }
      {
        name        = value 
        description = value used to set the dynamic parameter
        type        = string
      }
      {
        name        = filename 
        description = filename that contains values used to set the dynamic parameter
        type        = string
      }
      {
        name        = applyUdates 
        description = A flag indicating whether a NRTC should be allowed to update the parameter or freeze it at the current value(s).
        type        = boolean
      }
    ]
    requiredArgs = [ name ] 
  }


  {
    name            = diagnosticsSave
    description     = """Request Command.

This command saves diagnostic and/or telemetry data currently in the NRTC Telemetry Service to the Persistent Telemetry Storage (PTS) server. The interface to this command is TBD.

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = name 
        description = Name of diagnostic or telemetry data to save (TBD)
        type        = string
      }
      {
        name        = time 
        description = "timestamp range of data to save. Arrays is ordered [startTime endTime]"
        type        = array
        dimensions: [2]
        items = {
          type      = double
        }
        units         = "TAI / PTP"
      }
    ]
    requiredArgs = [ name, time ] 
  }

  {
    name            = bufferDump
    description     = """Request Command.

This command dumps the values currently in the circular buffers to the local hard drives. The NRTC pipeline must be stopped, via the pipelineStop command, prior to calling this command, to prevent the circular buffers from being modified during the write process.

By default the data is only saved locally on the NRTC machines. However, this command can optionally push copies of the circular buffers to the Persistent Telemetry Storage (PTS) server.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = prefix 
        description = "File name prefix. The path and post-fix of the file is determined by the RTC servers and is TBD."
        type        = string
      }
      {
        name        = pts 
        description = "A flag indicating if the buffer data should also be saved to the PTS for more permanent storage."
        type        = boolean
      }
    ]
    requiredArgs = [ prefix, pts ] 
  }

  {
    name            = lgsfFsmZero
    description     = """Request Command.

This command sends a zero command to all LGSF FSMs. This command is rejected if the LGS TT loop is closed. This zero command may be superimposed on to the dither signal, if NCP LGS dithering is enables (loop.lgsDither = NCP).

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.lgsTt[] = IDLE | INACTIVE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

  {
    name            = dmFlatten
    description     = """Request Command.

This command sends a system flat or mirror flat command to a DM. A MIRROR input corresponds to sending a zero command to the DM, while a SYSTEM input means the system flat, as specified by the RPG, will be sent to the DM.  A NONE input means the DM will not be moved. This command is rejected if either the high- or low-order loops are closed, or if the DMs are in the override calibration mode.

If both inputs are set to NONE, then this command is no-op and will return a warning.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.ho = IDLE
<li> loop.lo = IDLE
<li> calibWc.override[DM0 and/or DM11] = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = dm0
        description = "flatten DM0"
        enum        = [ SYSTEM, MIRROR, NONE ] 
      }
      {
        name        = dm11
        description = "flatten DM11"
        enum        = [ SYSTEM, MIRROR, NONE ] 
      }
    ]
    requiredArgs = [ dm0, dm11 ] 
  }

  {
    name            = ttsZero
    description     = """Request Command.

This command sends a system zero or mirror zero command to the TTS. A MIRROR input corresponds to sending a raw zero command to the TTS, meaning the stage is zeroed with respect to physical unit rotation relative to its mount. A SYSTEM input means the system zero position, as specified by the configuration file, will be sent to the TTS, corresponding the position of TTS that nominally aligns the system. This command is rejected if either the high- or low-order loops are closed, or if the TTS is in the override calibration mode.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.ho = IDLE
<li> loop.lo = IDLE
<li> calibWc.override[TTS] = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = tts
        description = "TTS zero command"
        enum        = [ SYSTEM, MIRROR ] 
      }
    ]
    requiredArgs = [ tts ] 
  }

  {
    name            = test
    description     = """Submit Command.

This command runs the automatic diagnostic self-test sequence. The details of the command are TBD.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

]

