subsystem = NFIRAOS
component = rtc

description = NRTC Assembly commands.

receive = [
  {
    name            = init
    description     = """Request Command.

The initialize command restores NRTC software to the state immediately after a boot-up. This command the deactivate the NRTC pipeline, via the pipelineDeactivate command, and will reset all internal states to default values, clear any mode configuration parameters and then request the specified configuration file from the TMT Configuration Service. Upon receiving the configuration file from the TMT configuration service, the NRTC will parse the configuration data and load it into memory. Additionally, by clearing the AO mode, this will stop all pixel reading until the AO mode is (re)set by the mode command.

An equivalent result to this command can be achieved by restarting the NRTC Assembly.

Discussion: There should be a convention to tell the NRTC to use a local version of the configure file(s) for engineering/integration purposes when the TMT configuration service is not yet available. This could be embedded in the configuration name/version.

Precondition:
<ul>
<li> none
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.mode = false
<li> config.name = {input}
<li> config.version = {input}
<li> all other internal parameters set to default values
</ul>"""
    args = [
      {
        name        = configName 
        description = Name of the configuration file to get from the TMT Configuration Service
        type        = string
      }
      {
        name        = configVersion
        description = Version of the configuration file to get from the TMT Configuration Service
        type        = string 
      }
    ]
  }  

  {
    name            = mode
    description     = """Request Command.

The configure command set the AO mode of the NRTC. On receiving this command the NRTC will deactivate the NRTC pipeline, via the pipelineDeactivate command and (re)-configure the AO mode of the RTC. This command will also (re-)establishes the private communication with the RPG by creating the mode appropriate connection end-points. Once the AO mode has been configured the RTC will begin to listen to pixels streams and perform pixel calibration for quick-look GUIs, however will not will not be saved or processed further.

The command will also configure which detector input streams will be used for low-order correction. These streams are split into tiers as listed below:
<ul>
<li> Tier 0 (optional)  PWFS providing TT measurements for acquisition purposes
<li> Tier 1 (required)  single detector that provides LO TTF(A) measurements 
<li> Tier 2 (optional)  1 to 2 detectors that provide LO TT or LO TTF(A) measurements
<li> Tier 3 (optional)  1 to 4 detectors that provide LOT TT measurements
<li> Tier 3F (optional)  single detector that provides LOT TTF measurements
</ul>
The restrictions for Tier assignments are given below:
<ul>
<li> Tier 0 can only be the PWFS
<li> Tier 1 must be either the PWFS or a TTF OIWFS
<li> Tier 2 can be the PWFS or any TT/TTF OIWFS or ODGW
<li> Tier 3 can be any TT OIWFS or ODGW
<li> Tier 3F can only be a TTF OIWFS
<li> a single detector can be assigned to multiple tiers
<li> the same detector cannot be assigned to the same tier twice
<li> the same detector cannot be assigned to both Tier 1 and Tier 2
<li> the same detector cannot be assigned to both Tier 3 and Tier 3F
</ul>

For Tiers 2 and 3, the order in which the detectors are specified defines the order in which the gradients will be assembled for low-order and low-order truth mode reconstruction. If a tier entry is specified as NONE, then that entry is skipped while assembling the low-order gradient vector.

The wavefront corrector rate must be a multiple of the high-order loop rate and the steady-state low-order loop rate. The steady-state low-order loop rate must be a multiple of the steady-state low-order truth loop rate.

Any OIWFS that is assigned to Tier 1 or Tier 3F must be set to TTF mode, while any OIWFS that is assigned to Tier 2 or Tier 3 can be either set to TT or TTF mode. All OIWFSs not assigned to a low-order tier must be set to the NONE mode.

Precondition:
<ul>
<li> state.cmd = READY 
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.mode = true
<li> mode.rateHo = {input rateHo}
<li> mode.rateLo = {input rateLo}
<li> mode.rateLot = {input rateLot}
<li> mode.rateWc = {input rateWc}
<li> mode.tier1 = {input tier1}
<li> mode.tier2[] = {input tier2}
<li> mode.tier3[] = {input tier3}
<li> mode.tier3f = {input tier3f}
<li> lgsState.enable[] = {input lgsEnable}
<li> pwfsState.bin = {input pwfsBin}
<li> oiwfsState.enable[] = {input oiwfs}
<li> if {input lgsEnable[*] == false}, then loop.lgsTt[*] = INACTIVE
<li> if {input tier2[] != ODGW* and input tier3[] != ODGW*}, 
  <ul>
  <li> then odgwState.enable[ODGW*] = false
  <li> else odgwState.enable[ODGW*] = true
  </ul>
<li> if {input tier2[*] == NONE}, then loop.tier2[*] = INACTIVE
<li> if {input tier3[*] == NONE}, then loop.tier3[*] = INACTIVE
<li> if {input tier3f == NONE}, then loop.tier3f = INACTIVE
<li> if {input tier1 != OIWFS* and input tier2[] != OIWFS*}, then loop.oiwfsPoa[OIWFS*] = INACTIVE
</ul>"""
    args = [
      {
        name        = lgsEnable
        description = "If an enable flag is true then the RTC will use the corresponding pixel stream for high-order correction. For NGS or SL mode, all LGS WFSs should be disabled. The array is ordered LGS WFS [A B C D E F]."
        type        = array
        dimensions: [6]
        items = {
          type      = boolean
        }
      }
      {
        name        = rateHo
        description = "high-order loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1
        units       = Hz 
      }
      {
        name        = rateLo
        description = "low-order loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1 
        units       = Hz
      }
      {
        name        = rateLot
        description = "low-order truth loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1 
        units       = Hz
      }
      {
        name        = rateWc
        description = "wavefront corrector loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1 
        units       = Hz
      }
      {
        name        = pwfsBin
        description = "width of PWFS bin in pixels" 
        enum        = [ 1, 2, 4, 8, 16, 32 ]
      }
      {
        name        = oiwfs
        description = "OIWFS mode. The array is ordered OIWFS [A B C]" 
        type        = array
        dimensions: [3]
        items = {
          enum      = [ NONE, TT, TTF ]
        }
      }
      {
        name        = tier1
        description = "Tier 1 detector." 
        enum        = [ PWFS, OIWFSA, OIWFSB, OIWFSC ]
      }
      {
        name        = tier2
        description = "Tier 2 detectors. The array is ordered Tier 2 [A B]"
        type        = array
        dimensions: [2]
        items = {
          enum      = [ NONE, PWFS, OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ]
        }
      }
      {
        name        = tier3
        description = "Tier 3 detectors. The array is ordered Tier 3 [A B C D]"
        type        = array
        dimensions: [4]
        items = {
          enum      = [ NONE, OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ] 
        }
      }
      {
        name        = tier3f
        description = "Tier 3F detector."
        enum        = [ NONE, OIWFSA, OIWFSB, OIWFSC ]
      }
      {
        name        = pol
        description = "indicates whether to perform pseudo open-loop (POL) feedback"
        type        = boolean
      }
    ]
    requiredArgs = [ lgsEnable, rateHo, rateLo, rateLot, rateWc, oiwfs, tier1, tier2, tier3, tier3f, pol ] 
  }

  {
    name            = stop
    description     = """Request Command.

This command will open all loops, via the loopOpen command, and abort the processing of an active submit command.

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.lgsBackgroud = false
</ul>"""
  }

  {
    name            = simulate
    description     = """Request Command.

At least on input parameter must be specified, all unspecified stages will remain unchanged.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> sim.dm0 = {input dm0}
<li> sim.dm11 = {input dm11}
<li> sim.lgs = {input lgs}
<li> sim.lgsf = {input lgsf}
<li> sim.odgw[] = {input odgw}
<li> sim.oiwfs[] = {input oiwfs}
<li> sim.pwfs = {input pwfs}
<li> sim.rpg = {input rpg}
<li> sim.tts = {input tts}
<li> sim.turbulence = {input turbulence}
</ul>"""
    args = [
      {
        name        = dm0 
        description = "Simulated DM0 flag."
        type        = boolean
      }
      {
        name        = dm11 
        description = "Simulated DM11 flag."
        type        = boolean
      }
      {
        name        = lgs 
        description = "Simulated LGS WFS flag."
        type        = boolean
      }
      {
        name        = lgsf 
        description = "Simulated LGSF FSMs flag."
        type        = boolean
      }
      {
        name        = odgw
        description = "Simulated ODGW flag. The array is ordered ODGW [1 2 3 4]."
        type        = array
        dimensions: [4]
        items = {
          type      = boolean
        }
      }
      {
        name        = oiwfs
        description = "Simulated OIWFS flag. The array is ordered OIWFS [A B C]."
        type        = array
        dimensions: [3]
        items = {
          type      = boolean
        }
      }
      {
        name        = pwfs 
        description = "Simulated PWFS flag."
        type        = boolean
      }
      {
        name        = rpg 
        description = "Simulated RPG flag."
        type        = boolean
      }
      {
        name        = tts 
        description = "Simulated TTS flag."
        type        = boolean
      }
      {
        name        = turbulence  
        description = "Simulated turbulence flag."
        type        = boolean
      }
    ]
  }


 {
    name            = calibLgsBackground
    description     = """Submit Command.

This command instructs the NRTC to take new normalized LGS WFS sky & instrument background and/or save the background to the TMT Configuration Service. This command applies to all enabled LGS WFSs.

If the number of frames to average is specified then the NRTC will average the specified number of frames to measure the current backgrounds. The current detector backgrounds, specified in the configuration file, are subtracted from the measured backgrounds to produce the sky & instrument backgrounds. These sky & instrument backgrounds are then normalized to a 1 second exposure and stored as the current normalized LGS WFS sky & instrument backgrounds in the NRTC, as which point the command returns. Subsequent call to this command will replace the normalized sky & instrument backgrounds and calls to the init command will reset all backgrounds to the defaults specified in the configuration file.

If the sky configuration name input parameter is specified, then the NRTC will save the current normalized sky & instrument backgrounds to the TMT Configuration Service using the configuration name given, after generating a new backgrounds if instructed to do so (i.e. number of frames to average is specified). Note that the configuration file will only contain the normalized sky & instrument backgrounds, and should be different from the configuration name used by the init command.

If neither input argument is specified, then this command will return with an error.

If pixels are not received from all enabled LGS WFSs in a timely manner (TBD), then this command will return with an error and no backgrounds will be updated or saved.

A call to the stop command will abort this process.

Discussion: It is assumed that the lasers will be detuned before executing this command so the sky & instrument backgrounds will include Rayleigh backscattering.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
<li> state.lgsBackgroud = true
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.lgsBackgroud = false
<li> if {input skyConfig not specified}, then state.unsavedLgsSky = true
<li> if {input skyConfig is specified}, then state.unsavedLgsSky = false
<li> if {input skyConfig is different from current LGS sky config file}, then state.unsavedConfig = true
</ul>"""
    args = [
      {
        name        = avg
        description = "number of frames to average"
        type        = integer
        minimum     = 0 
      }
      {
        name        = skyConfig
        description = "name of sky configuration file to save the current sky image to in the configuration service."
        type        = string
      }
    ]
  }

  {
    name            = calibModePixel
    description     = """Request Command.

This command sets which raw pixel data are sent directly to the RPG for calibration purposes. 

In CONTINUOUS mode the NRTC will continually stream (averaged) pixel frames to the RPG. The STOP mode will stop pixel frames from being sent to the RPG. The SINGLE mode will only send the next (averaged) pixel frame to the RPG at which point the pixel mode is reset to STOP. In the WC_SYNC mode average process will be delayed by the specified number of pixel frames after a WC override command has been applied. If an additional WC override command is received and applied before this delay has elapsed, then the delay is reset. 

The raw pixel averages value indicates the number of frames that will be averaged before the frame is sent to the RPG.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibDetector.pixelAvg[{input detector}] = {input avg}
<li> calibDetector.pixelMode[{input detector}] = {input mode}
<li> calibDetector.pixelDelay[{input detector}] = {input delay}
</ul>"""
    args = [
      {
        name        = detector  
        description = "indicates which detector pixel calibration mode to set."
        enum        = [LGSWFS ODGW OIWFS PWFS ALL]
      }
      {
        name        = mode
        description = "raw pixel calibration mode"
        enum        = [ STOP, SINGLE, CONTINUOUS, WC_SYNC ]
      }
      {
        name        = avg
        description = "number of pixel frames to average before sending to the RPG. This argument must be specified is the mode is set to SINGLE, CONTINUOUS or WC_SYNC."
        type        = integer
        minimum     = 1 
      }
      {
        name        = delay
        description = "number of pixel frames to delay (skip) before the starting to average pixel frames, after a WC override command has been applied. This argument must specified only when the mode is set to WC_SYNC. If an additional WC override command is received and applied before this delay time has elapsed, then the delay counter is reset. If a WC override command is not received after the mode is set to WC_SYNC or the WC override commands are disabled, then no averaged pixels will be returned."
        type       = integer
        minimum    = 0
      }
    ]
    requiredArgs = [ detector, mode ] 
  }

 {
    name            = calibModeGrad
    description     = """Request Command.

This command sets which gradients are sent directly to the RPG for calibration purposes.
 
This command works similarly to calibModePixel command, except instead of operating on raw pixels, this command operates on gradients, averaging the gradients from the specified detector and then sending that average to the RPG.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibDetector.gradAvg[{input detector}] = {input avg}
<li> calibDetector.gradMode[{input detector}] = {input mode}
<li> calibDetector.gradDelay[{input detector}] = {input delay}
</ul>"""
    args = [
      {
        name        = detector  
        description = "indicates which detector gradient calibration mode to set."
        enum        = [LGSWFS ODGW OIWFS PWFS ALL]
      }
      {
        name        = mode
        description = "gradient calibration mode"
        enum        = [ STOP, SINGLE, CONTINUOUS, WC_SYNC ]
      }
       {
        name        = avg
        description = "number of gradient frames to average before sending to the RPG. This argument must be specified is the mode is set to SINGLE, CONTINUOUS or WC_SYNC."
        type        = integer
        minimum     = 0 
      }
      {
        name        = delay
        description = "number of gradient frames to delay (skip) before the starting to average gradient frames, after a WC override command has been applied. (see calibModePixel command for more details)."
        type       = integer
        minimum    = 0
      }

    ]
    requiredArgs = [ detector, mode ] 
  }


  {
    name            = calibModeCmd
    description     = """Request Command.

This command sets what averaged DM and TTS commands are sent directly to the RPG. This command is intended for system flat calibration purposes.
 
This command works similarly to calibModePixel command, except instead of operating on raw  pixels, this command operates on DM and TTS commands, averaging the command sent to either the DM and TTS and then sending that average to the RPG.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
<li> calibWc.override = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibWc.avg[{input wc}] = {input avg}
<li> calibWc.mode[{input wc}] = {input mode}
</ul>"""
    args = [
      {
        name        = wc  
        description = "indicates which wavefront corrector command calibration mode to set."
        enum        = [DM0 DM11 TTS ALL]
      }
      {
        name        = mode
        description = "command calibration mode"
        enum        = [ STOP, SINGLE, CONTINUOUS ]
      }
      {
        name        = avg
        description = "number of command frames to average before sending to the RPG. This argument must be specified is the mode is set to SINGLE or CONTINUOUS."
        type        = integer
        minimum     = 0 
      }

    ]
    requiredArgs = [ wc, mode ] 
  }

 {
    name            = calibModeWc
    description     = """Request Command.

This command puts the NRTC wavefront controller into a calibration mode where the DMs and TTS can be adjusted directly by the RPG. This command is intended for calibration purposes. While in this calibrate override mode, the DMs and TTS are not updated by their normal path in the NRTC pipeline, but instead they listen for update streams directly from the RPG. While not in calibrate override mode, any WC override command from the RPG is ignored. This command will be rejected if the high or low-order loop is closed.

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
<li> loop.ho = IDLE
<li> loop.lo = IDLE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibWc.override = {input enable}
<li> if {input enable == true}, then calibWc.mode[] = STOP
</ul>"""
    args = [
      {
        name        = enable
        description = "enable or disable override commands from the RPG"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }


  {
    name            = pipelineActivate
    description     = """Request Command.

This command (re-)activate the NRTC pipeline by starting pixel processing, including gradient computation using CoG, and will flattening the DMs, via the dmFlatten command, zero the TTS, via the ttsZero command, zero the LGS FSMs, via the lgsfFsmZero command, and resetting integrators and filters, via the loopParamReset command. Subsequent calls to this command will re-activate the pipeline, opening all loops, via the loopOpen command, then resetting parameters and flattening/zeroing controlled elements. This command will also start saving telemetry stream to the RTS and pixel streams to the HOP servers.

Note that published control loop specific telemetry or telemetry sent directly to the RPG will not be started with this command, and will begin once the corresponding loop is closed. 

Discussion: It is anticipated that pixel reading will always occur as long as the NRTC software is running; it is therefore unaffected by this command.

Precondition:
<ul>
<li> state.cmd = READY 
<li> state.mode = true
<li> state.rpgDate = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> calibWc.override = false
<li> lgsState.algo = COG_STATIC | NONE
<li> lgsState.tt = KALMAN
<li> pwfsState.algo = COG_STATIC
<li> odgwState.algo[] = COG_STATIC | NONE
<li> oiwfsState.algo[] = COG_STATIC | NONE
<li> oiwfsState.acqTable[] = false
<li> odgwState.acqTable[] = false
</ul>"""
  }

  {
    name            = pipelineDeactivate
    description     = """Request Command.

This command deactivates the NRTC pipeline, i.e. stopping all closed-loop processing via the loopOpen command, and stopping pixel processing. This command is intended to stop the NRTC data processing, i.e. at the end of a night. This command does not stop the RTC pipeline software, instead it leaves the software in a stand-by state whereby the NRTC continues to respond to commands, and the pipeline can easily be reactivated. This command also stops the RTS and HOP servers from saving telemetry and pixel data.

Discussion: It is anticipated that pixel reading will always occur as long as the AO mode is set; it is therefore unaffected by this command. However, any pixels read while in this state are simply calibrated but not stored and will not be processed further.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
<li> calibDetector.pixelMode[] = STOP
<li> calibDetector.gradMode[] = STOP
<li> calibWc.mode[] = STOP
<li> calibWc.override = false
<li> lgsState.algo = NONE
<li> pwfsState.algo = NONE
<li> odgwState.algo[] = NONE
<li> oiwfsState.algo[] = NONE
</ul>"""
  }


  {
    name            = loopOpen
    description     = """Request Command.

This command opens all control loops and offloading in the RTC.

 Note that this command does not reset the integrator or filter states; use the pipelineActivate or loopParamReset command to reset those parameters.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.ho = IDLE
<li> loop.lgsFocus = IDLE
<li> loop.lgsDither = NONE
<li> loop.lgsTt[] = IDLE | INACTIVE
<li> loop.lo = IDLE
<li> loop.oiwfsPoa[] = IDLE | INACTIVE
<li> loop.pwfsDither = NONE
<li> loop.pwfsSsm = IDLE
<li> loop.m1Scallop = IDLE
<li> loop.telOffloadTt = IDLE
<li> loop.telOffloadFocus = IDLE
<li> loop.telOffloadMag = IDLE
<li> loop.telOffloadMode = IDLE
<li> loop.twfs = IDLE
<li> loop.tier0 = IDLE
<li> loop.tier1 = IDLE
<li> loop.tier2[] = IDLE | INACTIVE
<li> loop.tier3[] = IDLE | INACTIVE
<li> loop.tier3f = IDLE | INACTIVE
<li> if (lgsState.algo == MF_UPDATE), then lgsState.algo = MF_STATIC
<li> else if (lgsState.algo == MF_COG), then lgsState.algo = COG_STATIC
<li> if (pwfsState.algo == COG_UPDATE), then pwfsState.algo = COG_STATIC
<li> if (oiwfsState.algo == MF_UPDATE), then oiwfsState.algo = MF_STATIC
<li> else if (oiwfsState.algo == MF_COG), then oiwfsState.algo = COG_STATIC
<li> if (odgwState.algo == MF_UPDATE), then odgwState.algo = MF_STATIC
<li> else if (odgwState.algo == MF_COG), then odgwState.algo = COG_STATIC
</ul>"""
  }

  {
    name            = loopLgsFocus
    description     = """Request Command.

This command enables or disables the LGS focus loop, which publishing of the LGS trombone offset (lgsFocus) to control the NCC LGS trombone. While the focus error is above LGS focus threshold (from config file) the focus loop state will be ACQUIRE. Once the focus error has dropped below the threshold, the focus loop state will change to LOCK. Note that if the sodium layer estimate, and therefore prepositioning of the LGS trombone, is sufficient, then the initial focus should be below the threshold, and focus loop will be locked immediately. If the LGS focus loop is not IDLE, an enable request will be a no-op.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable} = true, then loop.lgsFocus != IDLE
<li> if {input enable} = false, then loop.lgsFocus = IDLE
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the LGS focus loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLgsTt
    description     = """Request Command.

This command enables or disables the LGS TT loop that sends command to the LGSF to control LGSF FSMs. When the loop is set to OPEN, TT correction commands to the LGSF are not updated and LGS TT loop is halted. However Kalman filter and integrator states are not reset, such that if FSM will remain at their current position; these states can be reset via the loopParamReset command. When the loop is set to CLOSE, the LGS TT loop is active and a TT drift terms are added to measured TT errors. When the loop is set to CLOSE_WO_DRIFT, the LGS TT loop is active but TT drift terms are ignored. Note that LGSF dither command are controlled independently by the loopLgsDither command, and the last available TT correction command stored in the integrator or Kalman filter while be added to the dither signal.

While the LGS TT error is above the LGS FSM TT threshold (from config file), the FSM TT loop state will be ACQUIRE. Once the TT error has dropped below the threshold the FSM TT loop state will change to LOCK. If the LGS TT loop is not IDLE, an enable request will be a no-op.

The control command will only be applied to the LGSF FSM corresponding to the enabled LGS WFSs (lgsState.enable[]). LGSF FSMs corresponding to disabled LGS WFSs will remain in the IDLE state and will be sent zeros.

Discussion: The acquisition of LGS TT may only take a few frames for the FSMs to move to the correct positions and start guiding. 

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input loop} = OPEN, then
  <ul> 
  <li> loop.lgsTt[] = IDLE | INACTIVE
  <li> loop.lgsDriftTt = false
  </ul>
<li> if {input loop} = CLOSE, then
  <ul> 
  <li> loop.lgsTt[] != IDLE
  <li> loop.lgsDriftTt = true
  </ul>
<li> if {input loop} = CLOSE_WO_DRIFT, then
  <ul> 
  <li> loop.lgsTt[] != IDLE
  <li> loop.lgsDriftTt = false
  </ul>
</ul>"""
    args = [
      {
        name        = loop  
        description = "indicates desired state of the LGS TT loop"
        enum        = [ OPEN, CLOSE, CLOSE_WO_DRIFT ]
      }
    ]
    requiredArgs = [ loop ] 
  }



 {
    name            = setLgsTtCntrl
    description     = """Request Command.

This command set controller type used in the LGS TT loop.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
<li> loop.lgsTt[] = IDLE | INACTIVE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> lgsState.tt = {input cntrl}
</ul>"""
    args = [
      {
        name        = cntrl  
        description = "desired LGSF FSM TT controller"
        enum        = [ INTEGRATOR, KALMAN ]
      }
    ]
    requiredArgs = [ cntrl ] 
  }

  {
    name            = loopTwfs
    description     = """Request Command.

This command enables or disables the TWFS loop which updates the LGS WFS TWFS/MFU reference vector based on PWFS measurements. 

If enabled, the TWFS portion of the TWFS/MFU reference vector is updated based on PWFS measurements. If the TWFS loop is not IDLE, an enable request will be a no-op. Note that the MFU portion of the TWFS/MFU reference vector is updated independently, which is enabled when LGS MF are being built/updated (lgsState.algo = MF_COG | MF_UPDATE). 

Disabling the TWFS loop does not reset the TWFS/MFU reference vector stored in the internal integrator, it merely stops any further TWFS updates from PWFS measurements. To reset the TWFS/MFU reference vector use the command loopParamReset. 

Disabling the TWFS reference vector merely stops the update to the TWFS reference vector and does not impact any other PWFS operation.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then loop.twfs != IDLE
<li> if {input !enable}, then loop.twfs = IDLE
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the TWFS loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopHigh
    description     = """Request Command.

This command enables or disables the high-order loop which applies the high-order correction errors to the control path. While waiting for the loop to stabilize, the high-order loop state will be set to ACQUIRE. Once the loop has stabilized, the high-order loop state will be set to LOCK. If the high-order loop is not IDLE, an enable request will be a no-op.

Disabling the high-order loop does not reset the correction vector stored in the main integrator; it merely stops the high-order error vector. To reset the main integrator use the command loopParamReset. Note that disabling the high-order correction does not interfere with the low-order path.

Discussion: The method we use to determine when the high-order loop is stabilized is TBD. This may entail ramping up the high-order path gain over several frames.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> calibWc.override = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then loop.ho != IDLE
<li> if {input !enable}, then loop.ho = IDLE
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the high-order loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLowTier0
    description     = """Request Command.

This command enables or disables Tier 0, the low-order loop using the PWFS to control TT and focus. This command is intended to be used as an optional first step in low-order acquisition.

If the Tier 1 and/or Tier 2 loops are already closed, or is acquiring, this command cannot be executed and will return an error. If either Tier 1 or 2 loops are closed while Tier 0 is active, then a TBD hand-off procedure is triggered and the Tier 0 loop will be opened.

Disabling the Tier 0 loop merely stops the PWFS update of low-order loop and does not impact any other PWFS operation.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.tier1 = IDLE
<li> loop.tier2[] = IDLE | INACTIVE
<li> calibWc.override = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then
  <ul>
  <li> loop.lo != IDLE
  <li> loop.tier0 != IDLE
  </ul>
<li> if {input !enable}, then 
  <ul>
  <li> loop.lo = IDLE
  <li> loop.tier0 = IDLE
  </ul>
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the Tier 0 loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }


  {
    name            = acqTableSet
    description     = """Request Command.

This command sets the guiding acquisition and dithering acquisition tables used by the OIWFSs and ODGWs.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.lo = IDLE
<li> oiwfsState.enable[{input detector}] = true
<li> odgwState.enable[{input detector}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> oiwfsState.acqTable[{input detector}] = true
<li> odgwState.acqTable[{input detector}] = true
</ul>"""
  args = [
      {
        name        = detector
        description = "indicates which detector the acquisition and dither tables are for."
        enum        = [ OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ]
      }
      {
        name        = guideTable
        description = """OIWFS/ODGW guiding acquisition table. The table will have the following columns:
  <ul>
  <li> step number
  <li> window size
  <li> frame rate
  <li> TBD detector parameters, e.g. exposure time, number of co-adds, ...
  <li> signal gain (the value corresponding to the locked row in the table is nominally 1)
  <li> next step number in the current table
  <li> corresponding step in the companion table, e.g. if the table is a guiding table then this column identifies the corresponding step number in the dither table, and vise versa
  <li> step label (TBC)
  </ul>


It is TBD how this table will be serialized and how to represent that data structure in the Interface Database.
"""
        type        = string
      }
      {
        name        = ditherTable
        description = """OIWFS/ODGW dithering acquisition table. This table will have the same format as the guiding acquisition table described in the guideTable argument."""
        type        = string
      }
    ]
    requiredArgs = [ detector, guideTable, ditherTable ] 
  }

  {
    name            = loopLowTier1
    description     = """Request Command.

This command enables or disables the low-order loop which applies low-order correction errors to the control path from the Tier 1 detector, i.e. the LO TTF detector. Enabling this loop triggers the Tier 1 acquisition process that steps through the Tier 1 acquisition table. While stepping through this table, the Tier 1 loop state is set to ACQUIRE. Once the acquisition process is complete the state is set to LOCK.

If the Tier 0 loop is closed, then a TBD hands-off procedure is performed to transition TTF control from the PWFS to the Tier 1 detector. If the PWFS is the Tier 1 detector, then this hands-off procedure is a no-op. 

If enabled, and the Tier 1 detector is already acquiring or locked, this command is a no-op. Additionally, if the Tier 1 detector is the PWFS then the ACQUIRE state is skipped since the PWFS does not have an acquisition procedure. If the PWFS is configured as the Tier 1 detector, disabling Tier 1 merely stops the PWFS control in the low-order path and does not impact any other PWFS operation.

Disabling Tier 1 will also disable Tier 3. 

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> calibWc.override = false
<li> if {loop.tier1 == OIWFS*}, then oiwfsState.acqTable[OIWFS*] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then
  <ul>
  <li> loop.lo != IDLE
  <li> loop.tier0 = IDLE
  <li> loop.tier1 != IDLE
  </ul>
<li> if {input !enable}, then 
  <ul>
  <li> loop.tier1 = IDLE
  <li> loop.tier3[] = IDLE | INACTIVE
  <li> loop.tier3f = IDLE | INACTIVE
  </ul>
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the Tier 1 loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLowTier2
    description     = """Request Command.

This command enables or disables the low-order loop which apples low-order correction errors to the control path from the Tier 2 detectors, i.e. the LO TT/TTF detectors. Enabling this loop triggers the Tier 2 acquisition process that steps through the Tier 2 acquisition tables. While stepping through these tables, the Tier 2 loop is set to ACQUIRE. Once the acquisition process is complete the state is set to LOCK. 

If enabling the Tier 2 loop but the detector is inactive (mode.tier2[] = NONE), then that detector is skipped and the corresponding Tier 2 state will be INACTIVE. If a Tier 2 detector is already acquiring or locked, this command is a no-op for that detector and will proceed to the next Tier 2 detector.

If the Tier 0 loop is closed, then a TBD hands-off procedure is performed to transition TT/TTF control from the PWFS to the Tier 2 detector(s). If the PWFS is the Tier 2 detector, then this hands-off procedure is a no-op and will proceed to the next Tier 2 detector. If PWFS in configured as a Tier 2 detector then disabling Tier 2 merely stops the PWFS control in the low-order path, and does not impact any other PWFS operation.

Disabling Tier 2 will also disable Tier 3.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> calibWc.override = false
<li> if {loop.tier2[] == ODGW*}, then odgwState.acqTable[ODGW*] = true
<li> if {loop.tier2[] == OIWFS*}, then oiwfsState.acqTable[OIWFS*] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then
  <ul>
  <li> if {at least one mode.tier2[] != NONE}, then loop.lo != IDLE
  <li> loop.tier0 = IDLE
  <li> loop.tier2[] != IDLE
  </ul>
<li> if {input !enable}, then 
  <ul>
  <li> loop.tier2[] = IDLE | INACTIVE
  <li> loop.tier3[] = IDLE | INACTIVE
  <li> loop.tier3f = IDLE | INACTIVE
  </ul>
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the Tier 1 loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLowTier3
    description     = """Request Command.

This command enables or disables the low-order loop which applies low-order correction errors to the control path from the Tier 3 and Tier 3F detectors, i.e., the LOT detectors. Enabling this loop triggers the Tier 3 and Tier 3F acquisition process that steps through the acquisition tables. While stepping through these tables, the Tier 3 loop state is set to ACQUIRE. Once the acquisition process has been completed the state is set to LOCK. 

Tier 3 can only be closed after Tier 1 and all active Tier 2 loops have been started, however Tier 3 acquisition will not start until after Tier 1 & 2 detectors have completed their acquisition (loop.tier1 = LOCK and loop.tier2[] = LOCK | INACTIVE). Therefore, if there are no active Tier 2 detectors, only Tier 1 must be acquired before closing Tier 3 loops.

If enabling is requested and a Tier 3 or 3F detector is inactive (mode.tier3[] = NONE or mode.tier3f = NONE), that detector is skipped and the corresponding Tier state will be INACTIVE. If a Tier 3 detector is already acquiring or locked, this command is a no-op for that senor and will proceed to the next Tier 3 detector.

Enabling the Tier 3 loo will set the LO path filter to a high-pass filter, and the LOT path filter to a low-pass filter. Conversely, disabling Tier 3 will set the low-order mode filter to an all-pass filter, and the low-order truth filter to be an all-stop filter.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.tier1 != IDLE
<li> loop.tier2[] != IDLE
<li> calibWc.override = false
<li> if {loop.tier3[] == ODGW*}, then odgwState.acqTable[ODGW*] = true
<li> if {loop.tier3[] == OIWFS*}, then oiwfsState.acqTable[OIWFS*] = true
<li> if {loop.tier3f == OIWFS*}, then oiwfsState.acqTable[OIWFS*] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then
  <ul>
  <li> loop.lo != IDLE
  <li> loop.tier3[] != IDLE
  <li> loop.tier3f != IDLE
  </ul>
<li> if {input !enable}, then 
  <ul>
  <li> loop.lo != IDLE
  <li> loop.tier3[] = IDLE | INACTIVE
  <li> loop.tier3f = IDLE | INACTIVE
  </ul>
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the Tier 3 loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLgsDither
    description     = """Request Command.

This command enables or disables LGS dithering. 

If non-common path (NCP) dithering is selected, then the NRTC applies the LGS dither signal applied to the LGSF FSM. The LGS dither signal is added to the LGSF FSM commands generated by the LGS TT loop (see the loopLgsTt command). If the LGS TT loop is stopped (loop.lgsTt[] = IDLE) before or during the application of the LGS dither signal, the dither signal is added to the current LGSF FSM command, as stored in the FSM integrator or Kalman filter. The dither signal will only be applied to the LGSF FSM corresponding to the enabled LGS WFSs (lgsState.enable[]).

If common path (CP) dithering is selected, then the CP LGS dither signal (tip/tilt) is applied to DM0. The CP dither signal is applied to the actuator commands generated by the wavefront corrector. If the High and Low-Order loops are stopped (loop.ho = IDLE and loop.lo = IDLE) before or during the application of the CP LGS dither signal, the dither signal is superimposed on the current DM0 shape, as stored in the main wavefront corrector integrator. This dither signal is completely independent of the PWFS dither signal described in the loopPwfsDither command.

If NONE is selected, then the NRTC will not dither DM0 or LGSF FSMs. Dithering cannot be set to none if the LGS gradient process is currently optimizing matched filter. 

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
<li> if {input enable == NONE}, then lgsState.algo != MF_COG | MF_UPDATE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.lgsDither = {input enable}
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the LGS Dithering loop"
        enum        = [ CP, NCP, NONE ]
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopPwfsDither
    description     = """Request Command.

This command enables or disables PWFS dithering. 

If non-common path (NCP) dithering is selected, then the NRTC assumes that NCC has, or will, be instructed to dither the NGS FSM. The NRTC will then listen to the NGS FSM sensed position stream from the NCC and estimate the dither signal for optimization and removal from the PWFS gradients. 

If common path (CP) dithering is selected, then the CP PWFS dither signal is applied to DM0. The CP dither signal is applied to the actuator commands generated by the wavefront corrector. If the High and Low-Order loops are stopped (loop.ho=IDLE & loop.lo=IDLE) before or during the application of the CP dither signal, the dither signal is superimposed on the current DM0 shape, as stored in the main wavefront corrector integrator. This dither signal is completely independent of the LGS dither signal described in the loopLgsDither command.

If NONE is selected, then the NRTC will not dither DM0 and will ignore the NGS FSM position stream.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> if {input enable == NONE}, then pwfsState.algo != GOG_UPDATE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.pwsfDither = {input enable}
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the PWFS Dithering loop"
        enum        = [ CP, NCP, NONE ]
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = algoSetLgs
    description     = """Request Command.

This command sets the LGS gradient computation algorithm.

When the LGS algorithm is set to MF_UPDATE, the LGS matched filter optimization is started. This algorithm can only be selected if LGS dithering is enabled (loop.lgsDither != NONE). If the previous algorithm was not MF_STATIC, then the LGS pixel processing does not have a set of matched filters, therefore it will initially use CoG (lgsState.algo = MF_COG) and once a set of matched filters has been computed then they will be applied to the pixel processing (lgsState.algo = MF_UPDATE). 

While matched filter optimization is enabled (lgsState.algo = MF_COG | MF_UPDATE) the  LGS dither DLL integrators, i<sub>0</sub> frames and matched filters will be updated. While not optimizing (lgsState.algo != MF_COG | MF_UPDATE) the updating of optimization parameters will be suspended. Re-enabling the optimization will append new data to the previously gathered statistics; however RTC will delay the new statistic gathering so the new data lines up in dither signal phase with where the old data left off. 

Enabling matched filter optimization will also trigger the updating of the MFU portion of the TWFS/MFU reference vector. However while the telescope is preforming a dither, the RTC should be instructed by the AOSQ suspend the matched filter optimization by switching to MF_STATIC or COG_STATIC.

When the LGS algorithm is set to COG_STATIC, the LGS gradients will be generated using center of gravity. Any matched filter statistic gathering will be suspended, but not reset. This is the default state after activating the pipeline, via the pipelineActivate command.

When the LGS algorithm is set to MF_STATIC, the LGS gradients will be generated using the current matched filters however will not updated the current matched filters. Matched filter statistic gathering will be suspended, but not reset. This algorithm can only be selected if the previous state was MF_UPDATE.

When the LGS algorithm is set to CUSTOM, the TBD...

Note that this command does not reset the  LGS dither DLL integrators, time-series of i<sub>b</sub> frames used to update the i<sub>0</sub> frame or matched filters. To reset the LGS optimization parameters the loopParamRest command can be used.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
<li> if {input enable == MF_UPDATE}, then loop.lgsDither = true
<li> if {input enable == MF_STATIC}, then lgsState.algo = MF_UPDATE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> lgsState.algo = {input algo} | MF_COG
</ul>"""
    args = [
      {
        name        = algo  
        description = ""
        enum        = [ COG_STATIC, MF_UPDATE, MF_STATIC, CUSTOM ]
      }
    ]
    requiredArgs = [ algo ] 
  }

 {
    name            = algoSetPwfs
    description     = """Request Command.

This command sets the PWFS gradient computation algorithm.

When the PWFS algorithm is set to GOG_UPDATE, the PWFS optical gain optimization is started. This algorithm can only be selected if PWFS dithering is enabled (loop.pwsfDither != NONE). However while the telescope is preforming a dither, the RTC should be instructed by the AOSQ halt optical gain optimization by switching to COG_STATIC.

While optical gain optimization is enabled (pwfsState.algo = GOG_UPDATE) the PWFS optical gain value and NCP dither DLL integrator will be updated. While not optimizing (pwfsState.algo != GOG_UPDATE) the updating of optimization parameters will be suspended. Re-enabling the optimization will append new data to the previously gathered statistics; however RTC will delay the new statistic gathering so the new data lines up in dither signal phase with where the old data left off. 

When the PWFS algorithm is set to COG_STATIC, the PWFS gradients will be generated using center of gravity. This is the default state after activating the pipeline, via the pipelineActivate command.

When the PWFS algorithm is set to CUSTOM, the TBD...

Note that this command does not reset the PWFS optical gain value or the NCP dither DLL integrator. To reset the optical gain the loopParamRest command can be used.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> if {input enable == GOG_UPDATE}, then loop.pwfsDither = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> pwfsState.algo[] = {input algo}
</ul>"""
    args = [
      {
        name        = algo  
        description = ""
        enum        = [ COG_STATIC, GOG_UPDATE, CUSTOM ]
      }
    ]
    requiredArgs = [ algo ] 
  }

 {
    name            = algoSetOiwfsOdgw
    description     = """Request Command.

This command sets the OIWFS/ODGW gradient computation algorithm.

When the OIWFS/ODGW algorithm is set to MF_UPDATE, the OIWFS/ODGW matched filter optimization is started. If the previous algorithm was not MF_STATIC, then the OIWFS/ODGW pixel processing does not have a matched filter, therefore it will initially use CoG (oiwfs/odgwState.algo = MF_COG) and once the matched filter has been computed then it will be applied to the pixel processing (oiwfs/odgwState.algo = MF_UPDATE). However while the telescope is preforming a dither or the detector is (re-)acquiring, the RTC should be instructed by the AOSQ halt the matched filter optimization by switching to MF_STATIC or COG_STATIC.

When the OIWFS/ODGW algorithm is set to BP, the OIWFS/ODGW gradients will be generated using the brightest pixel. 

When the OIWFS/ODGW algorithm is set to GOG_STATIC, the OIWFS/ODGW gradients will be generated using center of gravity (CoG).

When the OIWFS/ODGW algorithm is set to MF_STATIC, the OIWFS/ODGW gradients will be generated using the current matched filters however will not updated the current matched filters. This algorithm can only be selected if the previous state was MF_UPDATE.

When the OIWFS/ODGW algorithm is set to CUSTOM, the TBD...

Note that this command does not clear the current OIWFS/ODGW matched filters.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> oiwfsState.enable[{input detector}] != NONE 
<li> odgwState.enable[{input detector}] = true
<li> if {input algo == MF_STATIC}, then 
  <ul>
  <li> oiwfsState.algo[{input detector}] = MF_UPDATE
  <li> odgwState.algo[{input detector}] = MF_UPDATE
  </ul>
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> oiwfsState.algo[{input detector}] = {input algo} | MF_COG 
<li> odgwState.algo[{input detector}] = {input algo} | MF_COG 
</ul>"""
    args = [
      {
        name        = detector  
        description = ""
        enum        = [ OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ]
      }
      {
        name        = algo  
        description = ""
        enum        = [ COG_STATIC, MF_UPDATE, MF_STATIC, BP, CUSTOM ]
      }
    ]
    requiredArgs = [ algo ] 
  }


 {
    name            = offloadOiwfsPoa
    description     = """Request Command.

This command enables or disables low-order offloading to the OIWFS POAs. POA offload will only be activated for OIWFSs in Tier 1 and 2. 

If enabled, and the OIWFSs have not acquired their guide stars, the acquisition process is started. If the guide stars are already acquired, or are acquiring, as a result of Tiers 1 or 2 being enabled, then the acquisition process is allowed to complete. When enabled the NRTC will publish the POA offloading parameter (oiwfsPoa).

By default the NRTC will wait for OIWFS  acquisition to complete before offloading. However, if the acquisition offload flag (loop.oiwfsOffloadAcq) is set, then offloading begins immediately, even if the acquisition process ongoing. Additionally, offloading will be temporarily halted while dithering.

Disabling the POA offloading merely stops any offloading sent to the POA, and does not impact any other OIWFS operation.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.cmd = READY
<li> if {input enable}, then loop.oiwfsPoa[] != IDLE
<li> if {input !enable}, then loop.oiwfsPoa[] = IDLE | INACTIVE
</ul>"""
  args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the OIWFS POA offloading loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = offloadPwfsSsm
    description     = """Request Command.

This command enables or disables PWFS offloading to the NCC SSM.

When enabled the NRTC will publish the SSM offloading parameter (pwfsSsm).

Disabling the PWFS SSM offloading merely stops any offloading sent to the SSM, and does not impact any other PWFS operation.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then loop.pwfsSsm != IDLE
<li> if {input !enable}, then loop.pwfsSsm = IDLE
</ul>"""
  args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the OIWFS POA offloading loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = offloadTcs
    description     = """Request Command.

This command enables or disables offloading to the TCS.

When enabled the NRTC will publish various modes for the TCS (m1Scallop, telOffloadTt, telOffloadFocus, telOffloadMag, and/or telOffloadMode). 
 
Disabling the TCS offloading merely stops any offloading sent to the TCS, and does not impact any other pipeline operation.

At least one input argument must be specified.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input m1Scallop} 
  <ul>
  <li> then loop.m1Scallop != IDLE
  <li> else loop.m1Scallop = IDLE
  </ul>
<li> if {input telOffloadTt} 
  <ul>
  <li> then loop.telOffloadTt != IDLE
  <li> else loop.telOffloadTt = IDLE
  </ul>
<li> if {input telOffloadFocus} 
  <ul>
  <li> then loop.telOffloadFocus != IDLE
  <li> else loop.telOffloadFocus = IDLE
  </ul>
<li> if {input telOffloadMag} 
  <ul>
  <li> then loop.telOffloadMag != IDLE
  <li> else loop.telOffloadMag = IDLE
  </ul>
<li> if {input telOffloadMode} 
  <ul>
  <li> then loop.telOffloadMode != IDLE
  <li> else loop.telOffloadMode = IDLE
  </ul>
</ul>"""
  args = [
      {
        name        = m1Scallop
        description = "indicates whether to enable or disable the M1 scalloping"
        type        = boolean
      }
      {
        name        = telOffloadTt 
        description = "indicates whether to enable or disable the TT telescope offloading"
        type        = boolean
      }
      {
        name        = telOffloadFocus  
        description = "indicates whether to enable or disable the focus telescope offloading"
        type        = boolean
      }
      {
        name        = telOffloadMag 
        description = "indicates whether to enable or disable the magnification telescope offloading"
        type        = boolean
      }
      {
        name        = telOffloadMode  
        description = "indicates whether to enable or disable the telescope mode offloading"
        type        = boolean
      }
    ]
  }

  {
    name            = guideStarHandOff
    description     = """Request Command.

This command disables or (re-)enables a OIWFS or ODGW a guide star hand-off procedure for during non-sidereal tracking.

When disabled the NRTC temporarily ignore the detector stream, treating it as a loss of measurement, without raising alarms. When (re-)enabled the NRTC will attempt to acquire the guide star following the standard procedure.    

It is TBD whether the PWFS is required to perform guide star hand-off.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> oiwfsState.enable[{input detector}] != NONE 
<li> odgwState.enable[{input detector}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> oiwfsState.handOff[{input detector}] = {input disable} 
<li> odgwState.handOff[{input detector}] = {input disable}
</ul>"""
  args = [
      {
        name        = detector  
        description = ""
        enum        = [ OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ]
      }
      {
        name        = disable  
        description = "indicates whether to disable or (re-)enable the detector for guide star hand-off"
        type        = boolean
      }
    ]
    requiredArgs = [ detector, disable ] 
  }

  {
    name            = loopParamReset
    description     = """Request Command.

This command will reset one or more loop parameters. If only a parameter name prefix is specified, any parameter with the matching name prefix will be reset. The list of all possible loop parameters that can be reset by this command are: 
<ul>
<li> <b> wc_int </b> - wavefront corrector integrator (= 0)
<li> <b> wc_tt_lpf </b> - TTS filter states (= 0)
<li> <b> wc_tel_lpf	</b> - Telescope offload  high-pass filter states (= 0)
<li> <b> ho_m1Scallop_lpf </b> - M1 Scalloping  high-pass filter states (= 0)
<li> <b> ho_psd </b> - High-order PSD & WFE (discard gathered statistics)
<li> <b> ho_turb </b> - Slodar & other turbulence parameters (discard gathered statistics)
<li> <b> lo_kalman_state </b> - low-order Kalman filter states (= 0)
<li> <b> lo_kalman_avg </b> - low-order Kalman filter mode average feedback (= 0)
<li> <b> lo_mode_hpf </b> - low-order (Tier 1 & 2) high-pass filter states (= 0)
<li> <b> lo_mode_lpf </b> - low-order truth (Tier 3 & 3F) low-pass filter states (= 0)
<li> <b> lo_offload_lpf </b> - POA and SSM offload low-pass filter state (= 0)
<li> <b> lo_psd </b> - Low-order PSD & WFE (discard gathered statistics)
<li> <b> pwfs_opt_dll </b> - PWFS NCP dither DLL integrator and phase estimate (= 0)
<li> <b> pwfs_opt_gain </b> - PWFS optical gain (pwfsState.opticalGain = 1)
<li> <b> lgs_focus_lpf </b> - LGS focus low-pass filter states (= 0)
<li> <b> lgs_opt_dll </b> - LGS dither DLL integrators and phase estimates (= 0)
<li> <b> lgs_opt_mf </b> - LGS matched filters, if lgsState.algo == MF_UPDATE then lgsState.algo = MF_COG
<li> <b> lgs_opt_i0 </b> - LGS i<sub>0</sub> (discard gathered statistics, i.e. time-series of i<sub>b</sub> frames)
<li> <b> lgs_tt_int </b> - LGSF FSM integrator (= 0)
<li> <b> lgs_tt_kalman </b> - LGSF FSM Kalman filter states (= 0)
<li> <b> lgs_tt_psd </b> - LGS TT PSD (discard gathered statistics)
<li> <b> lgs_twfs_int </b>	- TWFS/MFU reference vector integrator (= 0)
</ul>

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = enable  
        description = "Name or name prefix of the loop parameter to reset. Passing an empty string will reset all loop parameters."
        type        = string
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = paramConfigSave
    description     = """Request Command.

This command tells the NRTC to save the current parameter configuration to the TMT configuration service using the specified parameter configuration name. 

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.unsavedConfig = false
</ul>"""
  args = [
       {
        name        = config 
        description = Name of the configuration file to save the current parameters to.
        type        = string
      }
    ]
    requiredArgs = [ config ] 
  }

  {
    name            = paramConfigSet
    description     = """Request Command.

This command tells the NRTC to set the value of any configuration parameter, i.e. a parameter that is specified in the parameter configuration file. The valid parameters for this command are TBD. This command is intended for constructing a new parameter configuration file as well as for engineering and debugging purposes. The NRTC will update the specified parameter, either by value or loading a file that contains the new value. The file format is dependent on the parameter specified and is TBD. Note the new parameter is not automatically saved to the configuration service and will be lost if the init command is called. To signal this condition, the unsaved parameter flag is set. To save the current configuration, use the paramConfigSave command.

Exactly one of the value or file arguments must be specified. Poetically the required argument will be set based on the parameter identifier (i.e. smaller parameters must use value while larger parameters must use file). The details for this command are TBD.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.unsavedConfig = true
</ul>"""
  args = [
       {
        name        = param 
        description = Configuration parameter identifier 
        type        = string
      }
      {
        name        = value 
        description = New value for the  specified parameter as a string
        type        = string
      }
      {
        name        = file 
        description = Full path to the file that contains the new data for the specified parameter 
        type        = string
      }
    ]
    requiredArgs = [ file ] 
  }

  {
    name            = paramOverride
    description     = """Request Command.

This command may be removed (TBC).

This command overrides the value of any dynamic parameter, i.e. one that is updated internally by the NRTC or by the RPG, or an event stream. The list of accepted parameters for this command is TBD. This command is intended for engineering and debugging purposes.

If the applyUpdates flag specified in the command is set to FALSE, the NRTC will stop applying updates for the specified parameter, in other words freezing the current value.
Similarly, if a new value is specified, either by the value or filename, the NRTC will stop applying updates and the current value is modified as specified.
 
The NRTC will only resume applying updates for the specified parameter after this command has been called with the applyUdates input flag set to TRUE, or the pipelineActivate command has been called.

Exactly one of the value, filename or applyUdates input arguments must be specified.

Discussion: Should there be a published override flag for every possible overridable parameter? 

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input value or filename is specified}, then override.{input name} = true (TBD)
<li> if {input applyUdates is specified}, then override.{input name} = {input !applyUdates} (TBD)
</ul>"""
  args = [
      {
        name        = name 
        description = Name of the dynamic parameter to update
        type        = string
      }
      {
        name        = value 
        description = value used to set the dynamic parameter
        type        = string
      }
      {
        name        = filename 
        description = filename that contains values used to set the dynamic parameter
        type        = string
      }
      {
        name        = applyUdates 
        description = A flag indicating whether a NRTC should be allowed to update the parameter or freeze it at the current value(s).
        type        = boolean
      }
    ]
    requiredArgs = [ name ] 
  }

  {
    name            = lgsfFsmZero
    description     = """Request Command.

This command sends a zero command to all LGSF FSMs. This command is rejected if the LGS TT loop is closed. This zero command may be superimposed on to the dither signal, if NCP LGS dithering is enables (loop.lgsDither = NCP).

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.lgsTt[] = IDLE | INACTIVE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

  {
    name            = dmFlatten
    description     = """Request Command.

This command sends a system flat or mirror flat command to a DM. A SYSTEM input corresponds to sending the system flat, as specified by the RPG, will be sent to the DM. A MIRROR input corresponds to sending a zero command to the DM, while a VIRGINIZE input means a decaying sinusoid is applied to the DM, result in a flat mirror. A NONE input means the DM will not be moved. This command is rejected if either the high- or low-order loops are closed, or if the DMs are in the override calibration mode.

If both inputs are set to NONE, then this command is no-op and will return a warning.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.ho = IDLE
<li> loop.lo = IDLE
<li> calibWc.override = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = dm0
        description = "flatten DM0"
        enum        = [ SYSTEM, MIRROR, VIRGINIZE, NONE ] 
      }
      {
        name        = dm11
        description = "flatten DM11"
        enum        = [ SYSTEM, MIRROR, VIRGINIZE, NONE ] 
      }
    ]
    requiredArgs = [ dm0, dm11 ] 
  }

  {
    name            = ttsZero
    description     = """Request Command.

This command sends a system zero or mirror zero command to the TTS. A MIRROR input corresponds to sending a raw zero command to the TTS, meaning the stage is zeroed with respect to physical unit rotation relative to its mount. A SYSTEM input means the system zero position, as specified by the configuration file, will be sent to the TTS, corresponding the position of TTS that nominally aligns the system. This command is rejected if either the high- or low-order loops are closed, or if the TTS is in the override calibration mode.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.ho = IDLE
<li> loop.lo = IDLE
<li> calibWc.override = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = tts
        description = "TTS zero command"
        enum        = [ SYSTEM, MIRROR ] 
      }
    ]
    requiredArgs = [ tts ] 
  }

  {
    name            = rtsDelete
    description     = """Request Command.

This command deletes data stored on the RTS, including PSFR data and nightly telemetry. Nightly telemetry data also included stored pixels, which are stored on the HOP servers.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = psfr
        description = "Delete all PSFR data that is older then the specified number of hours. A value of zero will delete all PSFR data (TBC)"
        type        = integer 
        units       = hours
      }
      {
        name        = telem
        description = "Delete all nightly telemetry data that is older then the specified number of hours. A value of zero will delete all nightly telemetry data (TBC)"
        type        = integer 
        units       = hours
      }
       {
        name        = tag
        description = "Delete tagged data stored on the RTS (TBC)"
        type        = string 
        units       = TBD
      }

    ]
  }

  {
    name            = rtsQuery 
    description     = """Request Command.

This command queries RTC for specific data. It is expected that this command will return a URL link to the required data, pointing to a webserver running on the RTS.

This command is TBD.

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }


  {
    name            = rtsSave 
    description     = """Request Command.

This command saves specific data as tagged data either saved on the RTS or pushed to the DMS. 

The interface to this command is TBD.

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
 args = [
      {
        name        = name 
        description = Name of diagnostic or telemetry data to save (TBD)
        type        = string
      }
      {
        name        = time 
        description = "timestamp range of data to save. Arrays is ordered [startTime endTime]"
        type        = array
        dimensions: [2]
        items = {
          type      = double
        }
        units         = "TAI / PTP"
      }
      {
        name        = dest 
        description = Destination of tagged data
        enum        = [ RTS, DMS ]
      }

    ]
    requiredArgs = [ name, time ] 

  }

  {
    name            = test
    description     = """Submit Command.

This command runs the automatic diagnostic self-test sequence. The details of the command are TBD.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

  {
    name            = bufferDump
    description     = """Request Command.

This command dumps the values currently in the circular buffers to the local hard drives. The NRTC pipeline must be deactivated, via the pipelineDeactivate command, prior to calling this command, to prevent the circular buffers from being modified during the write process.

By default the data is only saved locally on the NRTC machines. However, this command can optionally push copies of the circular buffers to the Real-time Telemetry Storage (RTS) server.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = prefix 
        description = "File name prefix. The path and post-fix of the file is determined by the RTC servers and is TBD."
        type        = string
      }
      {
        name        = rts 
        description = "A flag indicating if the buffer data should also be tagged and saved to the RTS for more permanent storage."
        type        = boolean
      }
    ]
    requiredArgs = [ prefix, rts ] 
  }



]


